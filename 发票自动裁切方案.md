# 发票自动裁切方案

## 目录

1. [项目概述](#一项目概述)
2. [技术架构](#二技术架构)
3. [系统流程设计](#三系统流程设计)
4. [服务架构设计](#四服务架构设计)
5. [配置说明](#五配置说明)
6. [API调用实现](#六api调用实现)
7. [图像裁切处理](#七图像裁切处理)
8. [RESTful API 接口设计](#八restful-api-接口设计)
9. [前端设计](#九前端设计)
10. [文件结构设计](#十文件结构设计)
11. [服务部署方案](#十一服务部署方案)
12. [注意事项与实现优先级](#十二注意事项与实现优先级)

---

## 一、项目概述

### 1.1 需求概述

使用火山引擎 SDK 调用 Doubao-Seed-1.6-vision 模型（版本 250815），实现：
- ✅ 上传 PDF 或图片文件
- ✅ 识别图片中的多张发票
- ✅ 定位每张发票的位置（边界框坐标）
- ✅ 根据定位信息裁切发票
- ✅ 输出独立的发票图片

### 1.2 核心要点

- **PDF 处理**: PDF 需要先转换为图片（模型不支持直接处理 PDF）
- **模型功能**: 模型返回定位信息，不直接裁切
- **裁切实现**: 根据模型返回的坐标进行图像裁切
- **服务化**: 设计为独立的微服务，支持通用业务调用
- **通用性**: 提供标准 RESTful API，可被多个业务系统集成

### 1.3 服务定位

本服务是一个**独立的发票识别与裁切服务**，提供：
- 统一的发票识别能力
- 标准化的 API 接口
- 可扩展的服务架构
- 支持多业务系统集成

---

## 二、技术架构

### 2.1 技术栈

- **后端框架**: Java Spring Boot
- **火山引擎 SDK**: volcengine-java-sdk
- **PDF 处理**: Apache PDFBox
- **图像处理**: Java BufferedImage / OpenCV Java
- **文件上传**: Spring Boot MultipartFile
- **JSON 处理**: Jackson / Gson
- **HTTP 客户端**: OkHttp / Apache HttpClient
- **定时任务**: Spring Task (@Scheduled)

### 2.2 核心依赖

#### Maven (pom.xml)

```xml
<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>3.1.0</version>
    </dependency>
    
    <!-- Spring Task 定时任务（已包含在 spring-boot-starter 中，无需额外添加） -->
    
    <!-- 火山引擎 SDK -->
    <dependency>
        <groupId>com.volcengine</groupId>
        <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
        <version>LATEST</version>
    </dependency>
    
    <!-- PDF 处理 -->
    <dependency>
        <groupId>org.apache.pdfbox</groupId>
        <artifactId>pdfbox</artifactId>
        <version>3.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.pdfbox</groupId>
        <artifactId>pdfbox-tools</artifactId>
        <version>3.0.0</version>
    </dependency>
    
    <!-- 图像处理 -->
    <dependency>
        <groupId>org.openpnp</groupId>
        <artifactId>opencv</artifactId>
        <version>4.8.0-0</version>
    </dependency>
    
    <!-- JSON 处理 -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
    
    <!-- HTTP 客户端 -->
    <dependency>
        <groupId>com.squareup.okhttp3</groupId>
        <artifactId>okhttp</artifactId>
        <version>4.11.0</version>
    </dependency>
    
    <!-- 工具类 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.12.0</version>
    </dependency>
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.11.0</version>
    </dependency>
</dependencies>
```

#### Gradle (build.gradle)

```gradle
dependencies {
    // Spring Boot
    implementation 'org.springframework.boot:spring-boot-starter-web:3.1.0'
    
    // 火山引擎 SDK
    implementation 'com.volcengine:volcengine-java-sdk-ark-runtime:LATEST'
    
    // PDF 处理
    implementation 'org.apache.pdfbox:pdfbox:3.0.0'
    implementation 'org.apache.pdfbox:pdfbox-tools:3.0.0'
    
    // 图像处理
    implementation 'org.openpnp:opencv:4.8.0-0'
    
    // JSON 处理
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    
    // HTTP 客户端
    implementation 'com.squareup.okhttp3:okhttp:4.11.0'
    
    // 工具类
    implementation 'org.apache.commons:commons-lang3:3.12.0'
    implementation 'commons-io:commons-io:2.11.0'
}
```

### 2.3 环境安装

#### 1. 安装 Java 环境

确保已安装 JDK 8 或更高版本：

```bash
# 检查 Java 版本
java -version

# 应该显示类似：
# openjdk version "17.0.x" 或更高版本
```

#### 2. 安装 Maven（如果使用 Maven）

```bash
# Windows
# 下载并安装 Maven: https://maven.apache.org/download.cgi
# 配置环境变量 MAVEN_HOME 和 PATH

# Linux/Mac
# 使用包管理器安装
sudo apt-get install maven  # Ubuntu/Debian
brew install maven          # Mac

# 验证安装
mvn -version
```

#### 3. 安装 Gradle（如果使用 Gradle）

```bash
# Windows
# 下载并安装 Gradle: https://gradle.org/install/
# 配置环境变量 GRADLE_HOME 和 PATH

# Linux/Mac
sudo apt-get install gradle  # Ubuntu/Debian
brew install gradle          # Mac

# 验证安装
gradle -version
```

#### 4. 安装项目依赖

**使用 Maven:**

```bash
# 进入项目目录
cd invoice

# 下载并安装依赖
mvn clean install

# 或者只下载依赖（不编译）
mvn dependency:resolve
```

**使用 Gradle:**

```bash
# 进入项目目录
cd invoice

# 下载并安装依赖
./gradlew build

# 或者只下载依赖
./gradlew dependencies
```

#### 5. 配置 IDE（可选）

**IntelliJ IDEA:**
1. File → Open → 选择项目目录
2. 等待 Maven/Gradle 自动导入依赖
3. 配置 JDK: File → Project Structure → Project → SDK

**Eclipse:**
1. File → Import → Existing Maven Projects
2. 选择项目目录
3. 等待依赖下载完成

**VS Code:**
1. 安装 Java Extension Pack
2. 打开项目目录
3. Maven/Gradle 插件会自动识别项目

---

## 三、系统流程设计

### 3.1 整体流程图

```
┌─────────────────────────────────────────────────────────────┐
│                     用户上传文件                              │
│              (PDF 或图片: JPG, PNG, etc.)                    │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
            ┌───────────────────────┐
            │   文件格式检测        │
            └───────┬───────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
┌───────────────┐      ┌───────────────┐
│   PDF 文件    │      │   图片文件    │
└───────┬───────┘      └───────┬───────┘
        │                      │
        │                      │
        ▼                      │
┌───────────────────────┐      │
│  PDF 转图片处理       │      │
│  - 使用 Apache PDFBox │      │
│  - 逐页转换为图片     │      │
│  - 保存为临时文件     │      │
└───────┬───────────────┘      │
        │                      │
        └──────────┬───────────┘
                   │
                   ▼
        ┌───────────────────────┐
        │   图片预处理           │
        │  - 格式统一            │
        │  - 尺寸检查            │
        └───────┬───────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│   调用火山引擎 Doubao-Seed-1.6-vision API     │
│   Model: 250815                                │
│                                                │
│   请求构建:                                    │
│   - 图片编码 (base64)                          │
│   - Prompt: "识别图片中所有发票的位置"         │
│   - 参数设置                                   │
└───────────────────────┬───────────────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   解析 API 返回结果            │
        │                                │
        │   期望返回格式:                │
        │   {                            │
        │     "invoices": [              │
        │       {                        │
        │         "bbox": [x1,y1,x2,y2],│
        │         "confidence": 0.95,    │
        │         "page": 1              │
        │       }                        │
        │     ]                          │
        │   }                            │
        └───────────────┬───────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   坐标系统转换                │
        │   - 确认坐标格式              │
        │   - 归一化坐标 → 像素坐标     │
        │   - 坐标验证                  │
        └───────────────┬───────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   遍历每张发票定位信息        │
        │   for invoice in invoices:    │
        └───────────────┬───────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   图像裁切处理                │
        │   - 读取原始图片              │
        │   - 提取边界框坐标            │
        │   - 使用 OpenCV/PIL 裁切      │
        │   - 添加边距（可选）          │
        └───────────────┬───────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   保存裁切后的发票图片        │
        │   - 文件名: invoice_P_N.jpg   │
        │     P: 页码, N: 发票序号      │
        │   - 保存到 outputs/ 目录      │
        └───────────────┬───────────────┘
                        │
                        ▼
        ┌───────────────────────────────┐
        │   返回结果给用户              │
        │   - 发票数量                  │
        │   - 文件列表/下载链接         │
        └───────────────────────────────┘
```

### 3.2 详细步骤说明

#### 步骤 1: 文件接收与预处理
- **输入**: PDF 文件或图片文件 (JPG, PNG 等)
- **处理**:
  - 如果是 PDF：使用 Apache PDFBox 将每一页转换为图片
  - 如果是图片：直接使用
- **输出**: 图片数组（每张图片对应一个页面）

#### 步骤 2: 调用火山引擎 API
- **模型**: Doubao-Seed-1.6-vision | 250815
- **输入**: 预处理后的图片
- **API 调用方式**:
  - 使用火山引擎 SDK 初始化客户端
  - 构建请求参数（包含图片数据）
  - 调用视觉理解 API
- **输出**: JSON 响应，包含每张发票的定位信息

#### 步骤 3: 解析定位信息
- **模型返回格式** (示例):
  ```json
  {
    "invoices": [
      {
        "bbox": [x1, y1, x2, y2],
        "confidence": 0.95,
        "page": 1
      }
    ]
  }
  ```
- **处理**: 解析 JSON，提取每张发票的边界框坐标

#### 步骤 4: 图像裁切
- **输入**: 原始图片 + 边界框坐标
- **处理**:
  - 使用 Java BufferedImage 或 OpenCV Java 根据坐标裁切图片
  - 坐标格式: [x1, y1, x2, y2]
- **输出**: 裁切后的发票图片数组

#### 步骤 5: 保存与返回
- **保存**: 将每张裁切后的发票保存为独立文件
- **命名规则**: `invoice_{page}_{index}.jpg`
- **返回**: 返回文件列表或下载链接

### 3.3 关键模块详细设计

#### PDF 转图片模块
```
输入: PDF 文件路径
      ↓
打开 PDF 文档 (Apache PDFBox)
      ↓
遍历每一页
      ↓
┌─────────────────────┐
│ 对每一页:            │
│ 1. 渲染为图片        │
│ 2. 设置分辨率 (DPI)  │
│ 3. 转换为字节流      │
│ 4. 保存或返回        │
└─────────────────────┘
      ↓
输出: 图片数组 (每页一张)
```

#### 火山引擎 API 调用模块
```
输入: 图片数据 (bytes 或 base64)
      ↓
初始化火山引擎客户端
      ↓
构建请求参数:
- endpoint: API 端点
- model: "Doubao-Seed-1.6-vision"
- version: "250815"
- image: 图片数据
- prompt: "请识别图片中所有发票的位置，返回每张发票的边界框坐标"
      ↓
发送 API 请求
      ↓
处理响应:
- 成功: 解析 JSON
- 失败: 错误处理和重试
      ↓
输出: 结构化数据 (发票定位信息)
```

#### 图像裁切模块
```
输入: 
- 原始图片 (BufferedImage 或 Mat)
- 边界框坐标 [x1, y1, x2, y2]
      ↓
坐标验证:
- 检查坐标是否在图片范围内
- 检查坐标有效性 (x2 > x1, y2 > y1)
      ↓
可选: 添加边距
- padding = 10 pixels
- x1 = max(0, x1 - padding)
- y1 = max(0, y1 - padding)
- x2 = min(width, x2 + padding)
- y2 = min(height, y2 + padding)
      ↓
执行裁切:
- BufferedImage: image.getSubimage(x1, y1, x2-x1, y2-y1)
- OpenCV: new Mat(image, new Rect(x1, y1, x2-x1, y2-y1))
      ↓
输出: 裁切后的发票图片
```

---

## 四、服务架构设计

### 4.1 服务架构概述

本服务设计为**独立的微服务**，采用 Spring Boot 框架，提供 RESTful API 接口，支持通用业务调用。

```
┌─────────────────────────────────────────────────────────────┐
│                    业务系统 A / B / C                        │
│              (通过 HTTP API 调用发票服务)                     │
└───────────────────────┬─────────────────────────────────────┘
                        │ HTTP RESTful API
                        ▼
        ┌───────────────────────────────────────┐
        │     发票识别与裁切服务 (Invoice Service) │
        │                                          │
        │  ┌──────────────────────────────────┐  │
        │  │  RESTful API Controller          │  │
        │  └──────────────┬───────────────────┘  │
        │                 │                        │
        │  ┌──────────────▼───────────────────┐  │
        │  │  Service Layer                    │  │
        │  │  - InvoiceService                 │  │
        │  │  - RecognitionService             │  │
        │  │  - CropService                    │  │
        │  └──────────────┬───────────────────┘  │
        │                 │                        │
        │  ┌──────────────▼───────────────────┐  │
        │  │  External Services                │  │
        │  │  - Volcengine API                 │  │
        │  └──────────────────────────────────┘  │
        └──────────────────────────────────────────┘
```

### 4.2 服务特性

#### 4.2.1 独立性
- **独立部署**: 可独立部署和运行
- **独立数据库**: 不依赖其他业务数据库
- **独立配置**: 拥有独立的配置文件和环境变量

#### 4.2.2 通用性
- **标准接口**: 提供标准 RESTful API
- **多格式支持**: 支持 PDF、JPG、PNG 等多种格式
- **灵活配置**: 支持通过配置调整参数

#### 4.2.3 可扩展性
- **水平扩展**: 支持多实例部署
- **异步处理**: 支持异步任务处理
- **插件化**: 支持扩展新的识别模型

### 4.3 服务接口设计原则

1. **RESTful 风格**: 遵循 REST 设计规范
2. **统一响应格式**: 统一的 JSON 响应结构
3. **错误处理**: 完善的错误码和错误信息
4. **版本控制**: API 版本管理
5. **文档完善**: 提供完整的 API 文档

### 4.4 服务调用方式

#### 4.4.1 同步调用
- 适用于小文件、快速处理场景
- 直接返回处理结果

#### 4.4.2 异步调用
- 适用于大文件、长时间处理场景
- 返回任务 ID，通过轮询获取结果

### 4.5 服务注册与发现（可选）

如果使用微服务架构，可以集成服务注册中心：

```yaml
# 支持 Nacos、Consul、Eureka 等
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        service-name: invoice-service
```

---

## 五、配置说明

### 4.1 火山引擎 API 配置

#### 必需配置项

```yaml
# application.yml 示例

volcengine:
  # API Key（从环境变量 ARK_API_KEY 或配置文件中读取）
  api-key: your_api_key_here
  
  # Base URL（默认值，可根据业务所在地域调整）
  base-url: https://ark.cn-beijing.volces.com/api/v3
  
  # 模型配置
  model:
    name: doubao-seed-1-6-vision-250815
```

```properties
# application.properties 示例

volcengine.api-key=your_api_key_here
volcengine.base-url=https://ark.cn-beijing.volces.com/api/v3
volcengine.model.name=doubao-seed-1-6-vision-250815
```

#### 环境变量配置（推荐）

**方式一：使用环境变量**

```bash
# Windows
set ARK_API_KEY=your_api_key_here

# Linux/Mac
export ARK_API_KEY=your_api_key_here
```

在代码中可以直接读取：

```java
String apiKey = System.getenv("ARK_API_KEY");
```

**方式二：使用配置文件**

将 API Key 配置在 `application-local.yml` 中（不提交到版本控制）：

```yaml
# application-local.yml（添加到 .gitignore）
volcengine:
  api-key: your_api_key_here
```

#### 如何获取配置信息

1. **登录火山引擎控制台**
   - 访问: https://console.volcengine.com/

2. **获取 API Key**
   - 进入"方舟" → "推理接入点"
   - 创建或查看推理接入点
   - 获取 API Key

3. **确认 Base URL**
   - 默认值: `https://ark.cn-beijing.volces.com/api/v3`
   - 可根据业务所在地域调整：
     - 北京: `https://ark.cn-beijing.volces.com/api/v3`
     - 其他地域请参考官方文档

4. **确认模型信息**
   - 模型名称: `doubao-seed-1-6-vision-250815`
   - 在控制台确认推理接入点 ID 对应的模型

### 4.2 应用配置

#### 文件路径配置

```yaml
# application.yml
app:
  upload-folder: uploads
  output-folder: outputs
  temp-folder: temp
  max-file-size: 52428800  # 50MB (字节)
  allowed-extensions:
    pdf: pdf
    image: jpg,jpeg,png,bmp,gif
```

#### 图像处理配置

```yaml
# application.yml
image:
  pdf:
    dpi: 300  # DPI 设置，影响图片质量
    scale: 2.0  # 缩放因子
  crop:
    padding: 10  # 裁切边距（像素）
    min-size: 100  # 最小裁切尺寸（像素）
  output:
    format: jpg  # 输出格式
    quality: 0.95  # JPEG 质量 (0.0-1.0)
```

#### API 调用配置

```yaml
# application.yml
api:
  timeout: 60  # 秒
  retry:
    max-retries: 3  # 最大重试次数
    delay: 1000  # 重试延迟（毫秒）
  prompt: |
    请识别图片中所有发票的位置。
    对于每张发票，请返回以下信息：
    1. 边界框坐标 (bbox): [x1, y1, x2, y2]，单位为像素
    2. 置信度 (confidence): 0-1之间的数值
    3. 页码 (page): 图片所在的页码
    
    请以 JSON 格式返回结果。
```

### 4.3 环境变量配置（推荐）

#### .env 文件示例

```env
# 火山引擎配置
ARK_API_KEY=your_api_key_here
VOLCENGINE_BASE_URL=https://ark.cn-beijing.volces.com/api/v3

# 模型配置
VOLCENGINE_MODEL_NAME=doubao-seed-1-6-vision-250815

# 应用配置
UPLOAD_FOLDER=uploads
OUTPUT_FOLDER=outputs
MAX_FILE_SIZE=50

# 图像处理配置
PDF_DPI=300
CROP_PADDING=10

# 资源回收配置
APP_CLEANUP_ENABLED=true
APP_CLEANUP_RETENTION_HOURS=24
APP_CLEANUP_CRON=0 0 2 * * ?
```

#### 使用 Spring Boot 配置类加载

```java
@Configuration
@ConfigurationProperties(prefix = "volcengine")
public class VolcengineConfig {
    private String apiKey;
    private String baseUrl = "https://ark.cn-beijing.volces.com/api/v3";
    private ModelConfig model;
    
    // getters and setters
    public String getApiKey() {
        // 优先从环境变量读取
        return apiKey != null ? apiKey : System.getenv("ARK_API_KEY");
    }
    
    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }
    
    public String getBaseUrl() {
        return baseUrl;
    }
    
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    public ModelConfig getModel() {
        return model;
    }
    
    public void setModel(ModelConfig model) {
        this.model = model;
    }
    
    public static class ModelConfig {
        private String name = "doubao-seed-1-6-vision-250815";
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
    }
}
```

### 4.4 安全配置

#### API 密钥安全

**❌ 不要这样做:**
```java
// 不要硬编码密钥
String ak = "AKLTxxxxxxxxxxxx";
```

**✅ 应该这样做:**
```java
// 使用配置文件或环境变量
@Value("${volcengine.api-key}")
private String apiKey;

// 或使用环境变量（推荐）
String apiKey = System.getenv("ARK_API_KEY");

// 配置文件不提交到版本控制
// 将 application-local.yml 添加到 .gitignore
```

#### .gitignore 配置

```gitignore
# 配置文件
application-local.yml
application-local.properties
.env

# 上传和输出文件
uploads/*
outputs/*
temp/*

# Java
target/
*.class
*.jar
*.war
*.ear
.idea/
*.iml
*.ipr
*.iws

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# 日志
logs/
*.log
```

---

## 六、API调用实现

### 5.1 SDK 安装与初始化

#### 安装 SDK

在 `pom.xml` 或 `build.gradle` 中添加依赖（见 2.2 节）

#### 初始化客户端

```java
package com.volcengine.ark.runtime;

import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class VolcengineClient {
    
    private final ArkService arkService;
    
    @Autowired
    public VolcengineClient(
            @Value("${volcengine.api-key}") String apiKey,
            @Value("${volcengine.base-url:https://ark.cn-beijing.volces.com/api/v3}") String baseUrl) {
        
        // 配置连接池和调度器
        ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
        Dispatcher dispatcher = new Dispatcher();
        
        // 初始化 ArkService
        this.arkService = ArkService.builder()
                .dispatcher(dispatcher)
                .connectionPool(connectionPool)
                .baseUrl(baseUrl)
                .apiKey(apiKey)
                .build();
    }
    
    public ArkService getArkService() {
        return arkService;
    }
    
    /**
     * 关闭服务（应用关闭时调用）
     */
    public void shutdown() {
        if (arkService != null) {
            arkService.shutdownExecutor();
        }
    }
}
```

**配置说明**:
- `apiKey`: 从环境变量 `ARK_API_KEY` 或配置文件中读取
- `baseUrl`: 默认值为 `https://ark.cn-beijing.volces.com/api/v3`，可根据业务所在地域调整
- 连接池和调度器用于优化 HTTP 连接性能

### 5.2 图片编码处理

#### 图片转 Base64

```java
import java.util.Base64;
import java.nio.file.Files;
import java.nio.file.Paths;

public class ImageUtils {
    
    /**
     * 将图片文件转换为 base64 编码
     */
    public static String imageToBase64(String imagePath) throws IOException {
        byte[] imageData = Files.readAllBytes(Paths.get(imagePath));
        return Base64.getEncoder().encodeToString(imageData);
    }
    
    /**
     * 将图片字节流转换为 base64 编码
     */
    public static String imageBytesToBase64(byte[] imageBytes) {
        return Base64.getEncoder().encodeToString(imageBytes);
    }
}
```

#### 图片格式处理

```java
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.imageio.ImageIO;

public class ImageUtils {
    
    /**
     * 准备图片：调整大小、转换格式
     */
    public static byte[] prepareImage(String imagePath, int maxSize) throws IOException {
        BufferedImage img = ImageIO.read(new File(imagePath));
        
        // 如果图片太大，进行缩放
        int maxDimension = Math.max(img.getWidth(), img.getHeight());
        if (maxDimension > maxSize) {
            double ratio = (double) maxSize / maxDimension;
            int newWidth = (int) (img.getWidth() * ratio);
            int newHeight = (int) (img.getHeight() * ratio);
            img = resizeImage(img, newWidth, newHeight);
        }
        
        // 转换为 RGB（如果是 RGBA）
        if (img.getType() != BufferedImage.TYPE_INT_RGB) {
            BufferedImage rgbImage = new BufferedImage(
                img.getWidth(), 
                img.getHeight(), 
                BufferedImage.TYPE_INT_RGB
            );
            Graphics2D g = rgbImage.createGraphics();
            g.drawImage(img, 0, 0, null);
            g.dispose();
            img = rgbImage;
        }
        
        // 转换为字节流
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(img, "jpg", baos);
        return baos.toByteArray();
    }
    
    private static BufferedImage resizeImage(BufferedImage originalImage, 
                                           int targetWidth, 
                                           int targetHeight) {
        BufferedImage resizedImage = new BufferedImage(
            targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB
        );
        Graphics2D g = resizedImage.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, 
                          RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g.drawImage(originalImage, 0, 0, targetWidth, targetHeight, null);
        g.dispose();
        return resizedImage;
    }
}
```

### 5.3 API 调用示例

#### 基础调用示例

```java
package com.volcengine.ark.runtime;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionContentPart;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

@Slf4j
@Service
public class VolcengineApiService {
    
    private final ArkService arkService;
    
    @Value("${volcengine.model.name:doubao-seed-1-6-vision-250815}")
    private String modelName;
    
    @Autowired
    public VolcengineApiService(VolcengineClient volcengineClient) {
        this.arkService = volcengineClient.getArkService();
    }
    
    /**
     * 调用火山引擎视觉模型 API
     * 
     * @param imagePath 图片文件路径
     * @return API 返回的文本内容
     */
    public String callVolcengineVisionApi(String imagePath) throws Exception {
        return callVolcengineVisionApi(imagePath, null);
    }
    
    /**
     * 调用火山引擎视觉模型 API（使用自定义 prompt）
     * 
     * @param imagePath 图片文件路径
     * @param customPrompt 自定义提示词（可选）
     * @return API 返回的文本内容
     */
    public String callVolcengineVisionApi(String imagePath, String customPrompt) throws Exception {
        try {
            // 准备图片 - 转换为 base64
            byte[] imageBytes = Files.readAllBytes(Paths.get(imagePath));
            String imageBase64 = Base64.getEncoder().encodeToString(imageBytes);
            String imageDataUrl = "data:image/jpeg;base64," + imageBase64;
            
            // 构建 Prompt
            String prompt = customPrompt != null ? customPrompt : 
                "请识别图片中所有发票的位置。\n" +
                "对于每张发票，请返回以下 JSON 格式的信息：\n" +
                "{\n" +
                "  \"invoices\": [\n" +
                "    {\n" +
                "      \"bbox\": [x1, y1, x2, y2],  // 边界框坐标，单位为像素\n" +
                "      \"confidence\": 0.95,         // 置信度 0-1\n" +
                "      \"page\": 1                   // 页码\n" +
                "    }\n" +
                "  ]\n" +
                "}\n" +
                "其中 bbox 格式为 [左上角x, 左上角y, 右下角x, 右下角y]";
            
            // 构建消息内容
            List<ChatCompletionContentPart> multiParts = new ArrayList<>();
            
            // 添加图片内容
            multiParts.add(ChatCompletionContentPart.builder()
                    .type("image_url")
                    .imageUrl(new ChatCompletionContentPart.ChatCompletionContentPartImageURL(imageDataUrl))
                    .build());
            
            // 添加文本内容
            multiParts.add(ChatCompletionContentPart.builder()
                    .type("text")
                    .text(prompt)
                    .build());
            
            // 构建消息列表
            List<ChatMessage> messages = new ArrayList<>();
            ChatMessage userMessage = ChatMessage.builder()
                    .role(ChatMessageRole.USER)
                    .multiContent(multiParts)
                    .build();
            messages.add(userMessage);
            
            // 构建请求
            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model(modelName)  // 模型名称：doubao-seed-1-6-vision-250815
                    .messages(messages)
                    .build();
            
            // 调用 API
            var response = arkService.createChatCompletion(chatCompletionRequest);
            
            // 解析响应
            if (response != null && response.getChoices() != null && !response.getChoices().isEmpty()) {
                String content = response.getChoices().get(0).getMessage().getContent();
                log.info("API 调用成功，返回内容长度: {}", content.length());
                return content;
            } else {
                throw new Exception("API 返回格式异常：未找到 choices");
            }
            
        } catch (Exception e) {
            log.error("API 调用失败: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * 使用图片 URL 调用 API（如果图片已上传到服务器）
     * 
     * @param imageUrl 图片 URL
     * @param customPrompt 自定义提示词（可选）
     * @return API 返回的文本内容
     */
    public String callVolcengineVisionApiWithUrl(String imageUrl, String customPrompt) throws Exception {
        try {
            // 构建 Prompt
            String prompt = customPrompt != null ? customPrompt : 
                "请识别图片中所有发票的位置。\n" +
                "对于每张发票，请返回以下 JSON 格式的信息：\n" +
                "{\n" +
                "  \"invoices\": [\n" +
                "    {\n" +
                "      \"bbox\": [x1, y1, x2, y2],\n" +
                "      \"confidence\": 0.95,\n" +
                "      \"page\": 1\n" +
                "    }\n" +
                "  ]\n" +
                "}";
            
            // 构建消息内容
            List<ChatCompletionContentPart> multiParts = new ArrayList<>();
            multiParts.add(ChatCompletionContentPart.builder()
                    .type("image_url")
                    .imageUrl(new ChatCompletionContentPart.ChatCompletionContentPartImageURL(imageUrl))
                    .build());
            multiParts.add(ChatCompletionContentPart.builder()
                    .type("text")
                    .text(prompt)
                    .build());
            
            // 构建消息列表
            List<ChatMessage> messages = new ArrayList<>();
            ChatMessage userMessage = ChatMessage.builder()
                    .role(ChatMessageRole.USER)
                    .multiContent(multiParts)
                    .build();
            messages.add(userMessage);
            
            // 构建并发送请求
            ChatCompletionRequest request = ChatCompletionRequest.builder()
                    .model(modelName)
                    .messages(messages)
                    .build();
            
            var response = arkService.createChatCompletion(request);
            
            if (response != null && response.getChoices() != null && !response.getChoices().isEmpty()) {
                return response.getChoices().get(0).getMessage().getContent();
            } else {
                throw new Exception("API 返回格式异常");
            }
            
        } catch (Exception e) {
            log.error("API 调用失败: {}", e.getMessage(), e);
            throw e;
        }
    }
}
```

#### 完整调用示例

```java
@Service
public class InvoiceRecognitionService {
    
    private final VolcengineApiService apiService;
    private final ApiResponseParser responseParser;
    
    @Autowired
    public InvoiceRecognitionService(VolcengineApiService apiService, 
                                    ApiResponseParser responseParser) {
        this.apiService = apiService;
        this.responseParser = responseParser;
    }
    
    /**
     * 识别图片中的发票位置
     * 
     * @param imagePath 图片文件路径
     * @return 发票定位信息列表
     */
    public List<Map<String, Object>> recognizeInvoices(String imagePath) throws Exception {
        // 1. 调用 API
        log.info("开始识别图片: {}", imagePath);
        String apiResponse = apiService.callVolcengineVisionApi(imagePath);
        
        // 2. 解析返回结果
        log.info("解析 API 返回结果...");
        List<Map<String, Object>> invoices = responseParser.parseApiResponse(apiResponse);
        
        // 3. 验证结果
        if (invoices.isEmpty()) {
            log.warn("未识别到发票");
            return Collections.emptyList();
        }
        
        log.info("识别到 {} 张发票", invoices.size());
        for (int i = 0; i < invoices.size(); i++) {
            Map<String, Object> invoice = invoices.get(i);
            @SuppressWarnings("unchecked")
            List<Integer> bbox = (List<Integer>) invoice.get("bbox");
            log.info("  发票 {}: bbox={}, confidence={}", 
                i + 1, bbox, invoice.get("confidence"));
        }
        
        return invoices;
    }
}
```

### 5.4 解析 API 返回结果

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;
import java.util.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

@Service
public class ApiResponseParser {
    
    private final ObjectMapper objectMapper;
    private static final Pattern JSON_PATTERN = Pattern.compile("\\{.*\\}", Pattern.DOTALL);
    private static final Pattern BBOX_PATTERN = Pattern.compile("\\[(\\d+),\\s*(\\d+),\\s*(\\d+),\\s*(\\d+)\\]");
    
    public ApiResponseParser() {
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * 解析 API 返回的文本，提取发票定位信息
     */
    public List<Map<String, Object>> parseApiResponse(String apiResponse) {
        List<Map<String, Object>> invoices = new ArrayList<>();
        
        // 尝试直接解析 JSON
        try {
            Matcher jsonMatcher = JSON_PATTERN.matcher(apiResponse);
            if (jsonMatcher.find()) {
                String jsonStr = jsonMatcher.group();
                JsonNode data = objectMapper.readTree(jsonStr);
                if (data.has("invoices")) {
                    JsonNode invoicesNode = data.get("invoices");
                    for (JsonNode invoice : invoicesNode) {
                        Map<String, Object> invoiceMap = new HashMap<>();
                        invoiceMap.put("bbox", objectMapper.convertValue(
                            invoice.get("bbox"), List.class));
                        invoiceMap.put("confidence", invoice.get("confidence").asDouble());
                        invoiceMap.put("page", invoice.get("page").asInt());
                        invoices.add(invoiceMap);
                    }
                }
            }
        } catch (Exception e) {
            // JSON 解析失败，继续尝试正则提取
        }
        
        // 如果直接解析失败，尝试正则提取
        if (invoices.isEmpty()) {
            Matcher bboxMatcher = BBOX_PATTERN.matcher(apiResponse);
            while (bboxMatcher.find()) {
                int x1 = Integer.parseInt(bboxMatcher.group(1));
                int y1 = Integer.parseInt(bboxMatcher.group(2));
                int x2 = Integer.parseInt(bboxMatcher.group(3));
                int y2 = Integer.parseInt(bboxMatcher.group(4));
                
                Map<String, Object> invoice = new HashMap<>();
                invoice.put("bbox", Arrays.asList(x1, y1, x2, y2));
                invoice.put("confidence", 0.9);  // 默认置信度
                invoice.put("page", 1);  // 默认页码
                invoices.add(invoice);
            }
        }
        
        return invoices;
    }
}
```

### 5.5 错误处理与重试

```java
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class RetryableApiService {
    
    private final VolcengineApiService apiService;
    
    @Autowired
    public RetryableApiService(VolcengineApiService apiService) {
        this.apiService = apiService;
    }
    
    /**
     * 带重试机制的 API 调用
     */
    @Retryable(
        value = {Exception.class},  // 根据实际异常类型调整
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public String callApiWithRetry(String imagePath, int maxRetries, long retryDelayMs) 
            throws Exception {
        int attempt = 0;
        long currentDelay = retryDelayMs;
        
        while (attempt < maxRetries) {
            try {
                return apiService.callVolcengineVisionApi(imagePath, 
                    "Doubao-Seed-1.6-vision", "250815");
            } catch (Exception e) {  // 根据实际异常类型调整
                attempt++;
                if (attempt < maxRetries) {
                    log.warn("API 调用失败，{}毫秒后重试... (尝试 {}/{})", 
                        currentDelay, attempt, maxRetries);
                    TimeUnit.MILLISECONDS.sleep(currentDelay);
                    currentDelay *= 2;  // 指数退避
                } else {
                    log.error("API 调用失败，已达到最大重试次数");
                    throw e;
                }
            }
        }
        throw new Exception("重试失败");
    }
}
```

### 5.6 API 响应格式说明

#### 期望的 API 响应格式

```json
{
  "id": "chatcmpl-xxx",
  "object": "chat.completion",
  "created": 1234567890,
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "{\"invoices\": [{\"bbox\": [100, 200, 800, 1200], \"confidence\": 0.95, \"page\": 1}]}"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150
  }
}
```

#### 发票定位信息格式

```json
{
  "invoices": [
    {
      "bbox": [100, 200, 800, 1200],
      "confidence": 0.95,
      "page": 1
    },
    {
      "bbox": [100, 1400, 800, 2400],
      "confidence": 0.92,
      "page": 1
    }
  ]
}
```

**坐标说明:**
- `bbox`: `[x1, y1, x2, y2]`
  - `x1, y1`: 左上角坐标
  - `x2, y2`: 右下角坐标
  - 单位: 像素
  - 原点: 图片左上角 (0, 0)

---

## 七、图像裁切处理

### 6.1 裁切流程概述

```
输入: 原始图片 + 边界框坐标
      ↓
坐标验证与修正
      ↓
添加边距（可选）
      ↓
执行裁切
      ↓
后处理（可选）
      ↓
保存裁切后的图片
```

### 6.2 坐标系统说明

#### 坐标格式

**标准格式**: `[x1, y1, x2, y2]`
- `x1, y1`: 左上角坐标
- `x2, y2`: 右下角坐标
- 原点: 图片左上角 (0, 0)
- 单位: 像素

```
(0,0) ──────────────→ X
  │
  │   ┌─────────┐
  │   │         │
  │   │ Invoice │
  │   │         │
  │   └─────────┘
  │
  ↓
  Y
```

#### 坐标验证

```java
import java.util.List;

public class BboxValidator {
    
    /**
     * 验证边界框坐标是否有效
     */
    public static BboxValidationResult validateBbox(List<Integer> bbox, 
                                                    int imageWidth, 
                                                    int imageHeight) {
        int x1 = bbox.get(0);
        int y1 = bbox.get(1);
        int x2 = bbox.get(2);
        int y2 = bbox.get(3);
        
        // 检查坐标顺序
        if (x2 <= x1 || y2 <= y1) {
            return new BboxValidationResult(false, null);
        }
        
        // 检查坐标范围
        if (x1 < 0 || y1 < 0 || x2 > imageWidth || y2 > imageHeight) {
            // 修正到图片范围内
            x1 = Math.max(0, x1);
            y1 = Math.max(0, y1);
            x2 = Math.min(imageWidth, x2);
            y2 = Math.min(imageHeight, y2);
            
            // 再次检查顺序
            if (x2 <= x1 || y2 <= y1) {
                return new BboxValidationResult(false, null);
            }
        }
        
        return new BboxValidationResult(true, List.of(x1, y1, x2, y2));
    }
    
    public static class BboxValidationResult {
        private final boolean valid;
        private final List<Integer> correctedBbox;
        
        public BboxValidationResult(boolean valid, List<Integer> correctedBbox) {
            this.valid = valid;
            this.correctedBbox = correctedBbox;
        }
        
        public boolean isValid() { return valid; }
        public List<Integer> getCorrectedBbox() { return correctedBbox; }
    }
}
```

### 6.3 使用 BufferedImage 裁切

#### 基础裁切

```java
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;

public class ImageCropService {
    
    /**
     * 使用 BufferedImage 裁切发票
     */
    public BufferedImage cropInvoice(String imagePath, List<Integer> bbox, 
                                    String outputPath) throws IOException {
        // 读取图片
        BufferedImage image = ImageIO.read(new File(imagePath));
        if (image == null) {
            throw new IllegalArgumentException("无法读取图片: " + imagePath);
        }
        
        int width = image.getWidth();
        int height = image.getHeight();
        
        // 验证坐标
        BboxValidationResult validation = BboxValidator.validateBbox(bbox, width, height);
        if (!validation.isValid()) {
            throw new IllegalArgumentException("无效的边界框坐标: " + bbox);
        }
        
        List<Integer> correctedBbox = validation.getCorrectedBbox();
        int x1 = correctedBbox.get(0);
        int y1 = correctedBbox.get(1);
        int x2 = correctedBbox.get(2);
        int y2 = correctedBbox.get(3);
        
        // 执行裁切
        BufferedImage cropped = image.getSubimage(x1, y1, x2 - x1, y2 - y1);
        
        // 保存（如果指定了输出路径）
        if (outputPath != null) {
            ImageIO.write(cropped, "jpg", new File(outputPath));
        }
        
        return cropped;
    }
    
    /**
     * 带边距的裁切
     */
    public BufferedImage cropWithPadding(String imagePath, List<Integer> bbox, 
                                        int padding, String outputPath) 
            throws IOException {
        BufferedImage image = ImageIO.read(new File(imagePath));
        int width = image.getWidth();
        int height = image.getHeight();
        
        int x1 = bbox.get(0);
        int y1 = bbox.get(1);
        int x2 = bbox.get(2);
        int y2 = bbox.get(3);
        
        // 添加边距
        x1 = Math.max(0, x1 - padding);
        y1 = Math.max(0, y1 - padding);
        x2 = Math.min(width, x2 + padding);
        y2 = Math.min(height, y2 + padding);
        
        // 裁切
        BufferedImage cropped = image.getSubimage(x1, y1, x2 - x1, y2 - y1);
        
        if (outputPath != null) {
            ImageIO.write(cropped, "jpg", new File(outputPath));
        }
        
        return cropped;
    }
}
```

### 6.4 使用 OpenCV Java 裁切（可选）

#### 基础裁切

```java
import org.opencv.core.*;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class OpenCvCropService {
    
    static {
        // 加载 OpenCV 本地库
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    
    /**
     * 使用 OpenCV 裁切发票
     */
    public Mat cropInvoiceOpenCv(String imagePath, List<Integer> bbox, 
                                String outputPath) {
        // 读取图片
        Mat image = Imgcodecs.imread(imagePath);
        if (image.empty()) {
            throw new IllegalArgumentException("无法读取图片: " + imagePath);
        }
        
        int width = image.width();
        int height = image.height();
        
        // 验证坐标
        BboxValidationResult validation = BboxValidator.validateBbox(bbox, width, height);
        if (!validation.isValid()) {
            throw new IllegalArgumentException("无效的边界框坐标: " + bbox);
        }
        
        List<Integer> correctedBbox = validation.getCorrectedBbox();
        int x1 = correctedBbox.get(0);
        int y1 = correctedBbox.get(1);
        int x2 = correctedBbox.get(2);
        int y2 = correctedBbox.get(3);
        
        // 执行裁切
        Rect rect = new Rect(x1, y1, x2 - x1, y2 - y1);
        Mat cropped = new Mat(image, rect);
        
        // 保存（如果指定了输出路径）
        if (outputPath != null) {
            Imgcodecs.imwrite(outputPath, cropped);
        }
        
        return cropped;
    }
}
```

### 6.5 PDF 转图片处理

```java
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.rendering.PDFRenderer;
import org.apache.pdfbox.rendering.ImageType;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.imageio.ImageIO;
import java.util.ArrayList;
import java.util.List;

@Service
public class PdfProcessor {
    
    /**
     * 将 PDF 转换为图片数组
     */
    public List<byte[]> pdfToImages(String pdfPath) throws IOException {
        List<byte[]> images = new ArrayList<>();
        
        try (PDDocument document = PDDocument.load(new File(pdfPath))) {
            PDFRenderer pdfRenderer = new PDFRenderer(document);
            
            // 遍历每一页
            for (int pageNum = 0; pageNum < document.getNumberOfPages(); pageNum++) {
                // 渲染为图片，DPI 设置为 300
                BufferedImage image = pdfRenderer.renderImageWithDPI(
                    pageNum, 300, ImageType.RGB);
                
                // 转换为字节流
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                ImageIO.write(image, "png", baos);
                images.add(baos.toByteArray());
            }
        }
        
        return images;
    }
    
    /**
     * 将 PDF 转换为 BufferedImage 列表
     */
    public List<BufferedImage> pdfToBufferedImages(String pdfPath) throws IOException {
        List<BufferedImage> images = new ArrayList<>();
        
        try (PDDocument document = PDDocument.load(new File(pdfPath))) {
            PDFRenderer pdfRenderer = new PDFRenderer(document);
            
            for (int pageNum = 0; pageNum < document.getNumberOfPages(); pageNum++) {
                BufferedImage image = pdfRenderer.renderImageWithDPI(
                    pageNum, 300, ImageType.RGB);
                images.add(image);
            }
        }
        
        return images;
    }
}
```

### 6.6 批量裁切处理

#### 处理单张图片的多张发票

```java
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
public class BatchCropService {
    
    private final ImageCropService imageCropService;
    
    @Autowired
    public BatchCropService(ImageCropService imageCropService) {
        this.imageCropService = imageCropService;
    }
    
    /**
     * 从一张图片中裁切多张发票
     */
    public List<String> cropMultipleInvoices(String imagePath, 
                                            List<Map<String, Object>> invoicesInfo, 
                                            String outputDir, 
                                            int padding) throws IOException {
        // 确保输出目录存在
        Files.createDirectories(Paths.get(outputDir));
        
        // 读取原始图片
        BufferedImage image = ImageIO.read(new File(imagePath));
        if (image == null) {
            throw new IllegalArgumentException("无法读取图片: " + imagePath);
        }
        
        int width = image.getWidth();
        int height = image.getHeight();
        
        List<String> outputFiles = new ArrayList<>();
        
        for (Map<String, Object> invoice : invoicesInfo) {
            @SuppressWarnings("unchecked")
            List<Integer> bbox = (List<Integer>) invoice.get("bbox");
            int page = (Integer) invoice.getOrDefault("page", 1);
            int index = (Integer) invoice.getOrDefault("index", 0);
            
            // 验证坐标
            BboxValidationResult validation = BboxValidator.validateBbox(bbox, width, height);
            if (!validation.isValid()) {
                log.warn("警告: 跳过无效的边界框 {}", bbox);
                continue;
            }
            
            List<Integer> correctedBbox = validation.getCorrectedBbox();
            int x1 = correctedBbox.get(0);
            int y1 = correctedBbox.get(1);
            int x2 = correctedBbox.get(2);
            int y2 = correctedBbox.get(3);
            
            // 添加边距
            x1 = Math.max(0, x1 - padding);
            y1 = Math.max(0, y1 - padding);
            x2 = Math.min(width, x2 + padding);
            y2 = Math.min(height, y2 + padding);
            
            // 裁切
            BufferedImage cropped = image.getSubimage(x1, y1, x2 - x1, y2 - y1);
            
            // 生成输出文件名
            String filename = String.format("invoice_%d_%d.jpg", page, index);
            String outputPath = Paths.get(outputDir, filename).toString();
            
            // 保存
            ImageIO.write(cropped, "jpg", new File(outputPath));
            outputFiles.add(outputPath);
            
            log.info("已保存: {}", outputPath);
        }
        
        return outputFiles;
    }
}
```

#### 完整裁切流程示例

```java
import java.util.*;

@Service
public class CompleteCropService {
    
    private final ImageCropService imageCropService;
    
    @Autowired
    public CompleteCropService(ImageCropService imageCropService) {
        this.imageCropService = imageCropService;
    }
    
    /**
     * 完整的裁切处理流程
     */
    public CropResult completeCropProcess(String imagePath, 
                                         List<Map<String, Object>> invoicesInfo, 
                                         String outputDir) throws IOException {
        Files.createDirectories(Paths.get(outputDir));
        
        // 1. 读取图片
        BufferedImage image = ImageIO.read(new File(imagePath));
        int width = image.getWidth();
        int height = image.getHeight();
        
        CropResult results = new CropResult();
        
        // 2. 处理每张发票
        for (int idx = 0; idx < invoicesInfo.size(); idx++) {
            Map<String, Object> invoice = invoicesInfo.get(idx);
            try {
                @SuppressWarnings("unchecked")
                List<Integer> bbox = (List<Integer>) invoice.get("bbox");
                int page = (Integer) invoice.getOrDefault("page", 1);
                
                // 3. 验证坐标
                BboxValidationResult validation = BboxValidator.validateBbox(bbox, width, height);
                if (!validation.isValid()) {
                    results.addFailed(idx, bbox, "无效的边界框坐标");
                    continue;
                }
                
                // 4. 添加边距
                List<Integer> correctedBbox = validation.getCorrectedBbox();
                int x1 = correctedBbox.get(0);
                int y1 = correctedBbox.get(1);
                int x2 = correctedBbox.get(2);
                int y2 = correctedBbox.get(3);
                
                int padding = 10;
                x1 = Math.max(0, x1 - padding);
                y1 = Math.max(0, y1 - padding);
                x2 = Math.min(width, x2 + padding);
                y2 = Math.min(height, y2 + padding);
                
                // 5. 执行裁切
                BufferedImage cropped = image.getSubimage(x1, y1, x2 - x1, y2 - y1);
                
                // 6. 保存
                String filename = String.format("invoice_%d_%d.jpg", page, idx);
                String outputPath = Paths.get(outputDir, filename).toString();
                ImageIO.write(cropped, "jpg", new File(outputPath));
                
                Map<String, Object> successInfo = new HashMap<>();
                successInfo.put("index", idx);
                successInfo.put("filename", filename);
                successInfo.put("path", outputPath);
                successInfo.put("bbox", Arrays.asList(x1, y1, x2, y2));
                results.addSuccess(successInfo);
                
            } catch (Exception e) {
                @SuppressWarnings("unchecked")
                List<Integer> bbox = (List<Integer>) invoice.get("bbox");
                results.addFailed(idx, bbox, e.getMessage());
            }
        }
        
        return results;
    }
    
    public static class CropResult {
        private final List<Map<String, Object>> success = new ArrayList<>();
        private final List<Map<String, Object>> failed = new ArrayList<>();
        
        public void addSuccess(Map<String, Object> info) {
            success.add(info);
        }
        
        public void addFailed(int index, List<Integer> bbox, String reason) {
            Map<String, Object> failedInfo = new HashMap<>();
            failedInfo.put("index", index);
            failedInfo.put("bbox", bbox);
            failedInfo.put("reason", reason);
            failed.add(failedInfo);
        }
        
        public List<Map<String, Object>> getSuccess() { return success; }
        public List<Map<String, Object>> getFailed() { return failed; }
    }
}
```

---

## 八、RESTful API 接口设计

### 8.1 API 基础信息

- **Base URL**: `http://localhost:8080/api/v1/invoice`
- **Content-Type**: `application/json` / `multipart/form-data`
- **响应格式**: JSON

### 8.2 统一响应格式

```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": "2024-01-01T12:00:00Z"
}
```

**响应码说明**:
- `200`: 成功
- `400`: 请求参数错误
- `401`: 认证失败
- `404`: 资源不存在
- `500`: 服务器内部错误
- `503`: 服务不可用

### 8.3 API 接口列表

#### 8.3.1 同步识别与裁切接口

**接口**: `POST /api/v1/invoice/recognize-and-crop`

**描述**: 上传文件，识别发票并裁切，同步返回结果

**请求参数**:
- `file` (MultipartFile, 必填): PDF 或图片文件
- `cropPadding` (Integer, 可选): 裁切边距，默认 10 像素
- `outputFormat` (String, 可选): 输出格式，默认 "jpg"

**请求示例**:
```bash
curl -X POST "http://localhost:8080/api/v1/invoice/recognize-and-crop" \
  -H "Content-Type: multipart/form-data" \
  -F "file=@invoice.pdf" \
  -F "cropPadding=10" \
  -F "outputFormat=jpg"
```

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "taskId": "task-123456",
    "totalInvoices": 3,
    "invoices": [
      {
        "index": 0,
        "page": 1,
        "bbox": [100, 200, 800, 1200],
        "confidence": 0.95,
        "imageUrl": "http://localhost:8080/api/v1/invoice/preview/cropped/invoice_1_0.jpg",
        "downloadUrl": "http://localhost:8080/api/v1/invoice/download/invoice_1_0.jpg",
        "originalImageUrl": "http://localhost:8080/api/v1/invoice/preview/original/task-123456?page=1",
        "filename": "invoice_1_0.jpg",
        "index": 0,
        "page": 1
      },
      {
        "index": 1,
        "page": 1,
        "bbox": [100, 1400, 800, 2400],
        "confidence": 0.92,
        "imageUrl": "http://localhost:8080/api/v1/invoice/download/invoice_1_1.jpg",
        "filename": "invoice_1_1.jpg"
      }
    ],
    "processingTime": 2.5
  },
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 8.3.2 异步识别与裁切接口

**接口**: `POST /api/v1/invoice/recognize-and-crop/async`

**描述**: 异步处理，返回任务 ID

**请求参数**: 同同步接口

**响应示例**:
```json
{
  "code": 200,
  "message": "任务已提交",
  "data": {
    "taskId": "task-123456",
    "status": "PROCESSING",
    "estimatedTime": 30
  },
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 8.3.3 查询任务状态接口

**接口**: `GET /api/v1/invoice/task/{taskId}`

**描述**: 查询异步任务状态和结果

**路径参数**:
- `taskId` (String, 必填): 任务 ID

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "taskId": "task-123456",
    "status": "COMPLETED",
    "progress": 100,
    "totalInvoices": 3,
    "invoices": [
      {
        "index": 0,
        "page": 1,
        "bbox": [100, 200, 800, 1200],
        "confidence": 0.95,
        "imageUrl": "http://localhost:8080/api/v1/invoice/download/invoice_1_0.jpg",
        "filename": "invoice_1_0.jpg"
      }
    ],
    "createdAt": "2024-01-01T12:00:00Z",
    "completedAt": "2024-01-01T12:00:30Z"
  },
  "timestamp": "2024-01-01T12:00:35Z"
}
```

**任务状态**:
- `PENDING`: 等待处理
- `PROCESSING`: 处理中
- `COMPLETED`: 已完成
- `FAILED`: 处理失败

#### 8.3.4 预览原始图片接口

**接口**: `GET /api/v1/invoice/preview/original/{taskId}`

**描述**: 预览原始上传的图片（PDF转图片后的原始图片）

**路径参数**:
- `taskId` (String, 必填): 任务 ID

**查询参数**:
- `page` (Integer, 可选): PDF 页码，从 1 开始。如果是图片文件，忽略此参数

**响应**: 图片文件流（Content-Type: image/jpeg 或 image/png）

**使用示例**:
```
GET /api/v1/invoice/preview/original/task-123456?page=1
```

#### 8.3.5 预览裁切后的图片接口

**接口**: `GET /api/v1/invoice/preview/cropped/{filename}`

**描述**: 预览裁切后的发票图片

**路径参数**:
- `filename` (String, 必填): 文件名，如 `invoice_1_0.jpg`

**响应**: 图片文件流（Content-Type: image/jpeg）

**使用示例**:
```
GET /api/v1/invoice/preview/cropped/invoice_1_0.jpg
```

#### 8.3.6 下载裁切后的图片接口

**接口**: `GET /api/v1/invoice/download/{filename}`

**描述**: 下载裁切后的发票图片

**路径参数**:
- `filename` (String, 必填): 文件名，如 `invoice_1_0.jpg`

**响应**: 图片文件流（Content-Disposition: attachment）

#### 8.3.7 下载原始图片接口

**接口**: `GET /api/v1/invoice/download/original/{taskId}`

**描述**: 下载原始上传的图片

**路径参数**:
- `taskId` (String, 必填): 任务 ID

**查询参数**:
- `page` (Integer, 可选): PDF 页码，从 1 开始

**响应**: 图片文件流（Content-Disposition: attachment）

#### 8.3.8 健康检查接口

**接口**: `GET /api/v1/invoice/health`

**描述**: 服务健康检查

**响应示例**:
```json
{
  "code": 200,
  "message": "service is healthy",
  "data": {
    "status": "UP",
    "version": "1.0.0",
    "uptime": "2h 30m"
  },
  "timestamp": "2024-01-01T12:00:00Z"
}
```

### 8.4 Service 层实现（预览功能支持）

#### 8.4.1 文件存储服务

```java
package com.invoice.service;

import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.UUID;

@Service
public class InvoiceService {
    
    private final Path originalStorageLocation;
    private final Path croppedStorageLocation;
    
    public InvoiceService(@Value("${app.upload-folder:uploads}") String uploadFolder,
                         @Value("${app.output-folder:outputs}") String outputFolder) {
        this.originalStorageLocation = Paths.get(uploadFolder, "original").toAbsolutePath().normalize();
        this.croppedStorageLocation = Paths.get(outputFolder).toAbsolutePath().normalize();
        
        try {
            Files.createDirectories(this.originalStorageLocation);
            Files.createDirectories(this.croppedStorageLocation);
        } catch (Exception ex) {
            throw new RuntimeException("无法创建存储目录", ex);
        }
    }
    
    /**
     * 保存原始文件（用于预览）
     */
    public String saveOriginalFile(MultipartFile file, String taskId) throws IOException {
        String filename = String.format("%s_original.%s", 
            taskId, getFileExtension(file.getOriginalFilename()));
        Path targetLocation = this.originalStorageLocation.resolve(filename);
        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
        return filename;
    }
    
    /**
     * 保存PDF转换后的原始图片（用于预览）
     */
    public String saveOriginalImage(byte[] imageData, String taskId, int page) throws IOException {
        String filename = String.format("%s_page_%d.jpg", taskId, page);
        Path targetLocation = this.originalStorageLocation.resolve(filename);
        Files.write(targetLocation, imageData);
        return filename;
    }
    
    /**
     * 获取原始图片资源
     */
    public Resource getOriginalImageResource(String taskId, int page) throws IOException {
        // 尝试获取指定页码的图片
        String filename = String.format("%s_page_%d.jpg", taskId, page);
        Path filePath = this.originalStorageLocation.resolve(filename).normalize();
        
        // 如果不存在，尝试获取原始文件
        if (!Files.exists(filePath)) {
            filename = String.format("%s_original.*", taskId);
            // 查找匹配的文件
            try (var stream = Files.list(this.originalStorageLocation)) {
                filePath = stream
                    .filter(path -> path.getFileName().toString().startsWith(taskId + "_original"))
                    .findFirst()
                    .orElseThrow(() -> new IOException("原始文件不存在"));
            }
        }
        
        Resource resource = new UrlResource(filePath.toUri());
        if (resource.exists()) {
            return resource;
        } else {
            throw new IOException("文件不存在: " + filename);
        }
    }
    
    /**
     * 获取裁切后的图片资源
     */
    public Resource getCroppedImageResource(String filename) throws IOException {
        Path filePath = this.croppedStorageLocation.resolve(filename).normalize();
        Resource resource = new UrlResource(filePath.toUri());
        if (resource.exists()) {
            return resource;
        } else {
            throw new IOException("文件不存在: " + filename);
        }
    }
    
    private String getFileExtension(String filename) {
        if (filename == null || filename.isEmpty()) {
            return "bin";
        }
        int lastDot = filename.lastIndexOf('.');
        return lastDot > 0 ? filename.substring(lastDot + 1) : "bin";
    }
}
```

### 8.5 资源回收机制

#### 8.5.1 资源回收概述

PDF 处理和图像裁切会产生大量临时文件，需要定期清理以避免磁盘空间耗尽。本方案使用 **Spring Task** 定时任务实现自动资源回收。

**清理目标**:
- `uploads/` 目录：上传的原始文件
- `temp/` 目录：临时处理文件
- `outputs/` 目录：默认不清理（可根据需要配置）

**清理策略**:
- 默认保留时间：24小时
- 清理时机：每天凌晨2点自动执行
- 清理条件：文件最后修改时间超过保留时间

#### 8.5.2 资源回收服务实现

已在 8.4.2 节提供完整的 `FileCleanupService` 实现，包括：
- 定时清理任务（`@Scheduled`）
- 文件遍历和删除逻辑
- 空目录清理
- 清理统计和日志记录

#### 8.5.3 配置说明

```yaml
# application.yml
app:
  cleanup:
    enabled: true                    # 是否启用自动清理
    retention-hours: 24              # 文件保留时间（小时）
    cron: "0 0 2 * * ?"             # Cron 表达式：每天凌晨2点执行
```

**Cron 表达式示例**:
- `"0 0 2 * * ?"` - 每天凌晨2点执行
- `"0 0 */6 * * ?"` - 每6小时执行一次
- `"0 0 2 * * MON-FRI"` - 工作日凌晨2点执行
- `"0 0 0 * * ?"` - 每天午夜执行

#### 8.5.4 清理策略建议

**生产环境建议**:
- 保留时间：根据业务需求调整（建议24-72小时）
- 清理频率：每天1-2次，避免在业务高峰期执行
- 监控告警：监控磁盘使用率，设置告警阈值

**开发/测试环境**:
- 可以设置较短的保留时间（如12小时）
- 可以增加清理频率（如每6小时）

#### 8.5.5 注意事项

1. **文件访问冲突**
   - 清理任务执行时，可能正在处理文件
   - 建议在清理前检查文件是否正在使用
   - 可以使用文件锁机制避免冲突

2. **磁盘空间监控**
   - 建议集成磁盘空间监控
   - 当磁盘使用率超过阈值时，可以提前触发清理

3. **清理日志**
   - 记录清理的文件数量和大小
   - 便于问题排查和容量规划

4. **outputs 目录处理**
   - 默认不清理 outputs 目录（用户可能需要下载）
   - 如需清理，建议设置更长的保留时间（如7天）

#### 8.5.6 增强版清理服务（可选）

```java
@Service
public class EnhancedFileCleanupService {
    
    /**
     * 检查磁盘空间，如果不足则提前清理
     */
    @Scheduled(fixedRate = 3600000) // 每小时检查一次
    public void checkDiskSpace() {
        File disk = new File(uploadFolder);
        long totalSpace = disk.getTotalSpace();
        long freeSpace = disk.getFreeSpace();
        double usagePercent = (1.0 - (double) freeSpace / totalSpace) * 100;
        
        if (usagePercent > 80) { // 磁盘使用率超过80%
            log.warn("磁盘使用率过高: {}%, 提前触发清理", usagePercent);
            manualCleanup();
        }
    }
    
    /**
     * 清理指定目录，排除正在使用的文件
     */
    private void cleanupDirectorySafely(String directoryPath) {
        // 实现安全的清理逻辑
        // 检查文件是否被锁定或正在使用
    }
}
```

### 8.6 Controller 实现示例

```java
package com.invoice.controller;

import com.invoice.dto.ApiResponse;
import com.invoice.dto.InvoiceRecognizeRequest;
import com.invoice.dto.InvoiceRecognizeResponse;
import com.invoice.service.InvoiceService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.concurrent.CompletableFuture;

@Slf4j
@RestController
@RequestMapping("/api/v1/invoice")
public class InvoiceController {
    
    @Autowired
    private InvoiceService invoiceService;
    
    /**
     * 同步识别与裁切
     */
    @PostMapping(value = "/recognize-and-crop", 
                 consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<InvoiceRecognizeResponse>> recognizeAndCrop(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "cropPadding", defaultValue = "10") Integer cropPadding,
            @RequestParam(value = "outputFormat", defaultValue = "jpg") String outputFormat) {
        
        try {
            // 验证文件
            if (file.isEmpty()) {
                return ResponseEntity.badRequest()
                    .body(ApiResponse.error(400, "文件不能为空"));
            }
            
            // 调用服务（保存原始文件用于预览）
            InvoiceRecognizeResponse response = invoiceService.recognizeAndCrop(
                file, cropPadding, outputFormat);
            
            // 为每个发票添加预览URL和下载URL
            String taskId = response.getTaskId();
            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
                .getRequestAttributes()).getRequest();
            String baseUrl = request.getScheme() + "://" + request.getServerName() 
                + ":" + request.getServerPort() + "/api/v1/invoice";
            
            response.getInvoices().forEach(invoice -> {
                // 设置裁切后图片预览URL
                String croppedPreviewUrl = String.format("%s/preview/cropped/%s", 
                    baseUrl, invoice.getFilename());
                invoice.setImageUrl(croppedPreviewUrl);
                
                // 设置裁切后图片下载URL
                String croppedDownloadUrl = String.format("%s/download/%s", 
                    baseUrl, invoice.getFilename());
                invoice.setDownloadUrl(croppedDownloadUrl);
                
                // 设置原始图片预览URL
                String originalPreviewUrl = String.format("%s/preview/original/%s?page=%d", 
                    baseUrl, taskId, invoice.getPage());
                invoice.setOriginalImageUrl(originalPreviewUrl);
            });
            
            return ResponseEntity.ok(ApiResponse.success(response));
            
        } catch (Exception e) {
            log.error("识别失败", e);
            return ResponseEntity.status(500)
                .body(ApiResponse.error(500, "处理失败: " + e.getMessage()));
        }
    }
    
    /**
     * 异步识别与裁切
     */
    @PostMapping(value = "/recognize-and-crop/async",
                 consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<AsyncTaskResponse>> recognizeAndCropAsync(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "cropPadding", defaultValue = "10") Integer cropPadding,
            @RequestParam(value = "outputFormat", defaultValue = "jpg") String outputFormat) {
        
        try {
            String taskId = invoiceService.submitAsyncTask(file, cropPadding, outputFormat);
            AsyncTaskResponse response = new AsyncTaskResponse();
            response.setTaskId(taskId);
            response.setStatus("PROCESSING");
            
            return ResponseEntity.ok(ApiResponse.success(response));
            
        } catch (Exception e) {
            log.error("提交任务失败", e);
            return ResponseEntity.status(500)
                .body(ApiResponse.error(500, "提交任务失败: " + e.getMessage()));
        }
    }
    
    /**
     * 查询任务状态
     */
    @GetMapping("/task/{taskId}")
    public ResponseEntity<ApiResponse<TaskStatusResponse>> getTaskStatus(
            @PathVariable String taskId) {
        
        try {
            TaskStatusResponse response = invoiceService.getTaskStatus(taskId);
            return ResponseEntity.ok(ApiResponse.success(response));
            
        } catch (Exception e) {
            log.error("查询任务状态失败", e);
            return ResponseEntity.status(500)
                .body(ApiResponse.error(500, "查询失败: " + e.getMessage()));
        }
    }
    
    /**
     * 预览原始图片
     */
    @GetMapping("/preview/original/{taskId}")
    public ResponseEntity<Resource> previewOriginalImage(
            @PathVariable String taskId,
            @RequestParam(value = "page", defaultValue = "1") Integer page) {
        try {
            Resource resource = invoiceService.getOriginalImageResource(taskId, page);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .header("Cache-Control", "public, max-age=3600")
                .body(resource);
                
        } catch (Exception e) {
            log.error("预览原始图片失败", e);
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 预览裁切后的图片
     */
    @GetMapping("/preview/cropped/{filename}")
    public ResponseEntity<Resource> previewCroppedImage(@PathVariable String filename) {
        try {
            Resource resource = invoiceService.getCroppedImageResource(filename);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .header("Cache-Control", "public, max-age=3600")
                .body(resource);
                
        } catch (Exception e) {
            log.error("预览裁切图片失败", e);
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 下载裁切后的图片
     */
    @GetMapping("/download/{filename}")
    public ResponseEntity<Resource> downloadCroppedImage(@PathVariable String filename) {
        try {
            Resource resource = invoiceService.getCroppedImageResource(filename);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .header("Content-Disposition", "attachment; filename=\"" + filename + "\"")
                .body(resource);
                
        } catch (Exception e) {
            log.error("下载图片失败", e);
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 下载原始图片
     */
    @GetMapping("/download/original/{taskId}")
    public ResponseEntity<Resource> downloadOriginalImage(
            @PathVariable String taskId,
            @RequestParam(value = "page", defaultValue = "1") Integer page) {
        try {
            Resource resource = invoiceService.getOriginalImageResource(taskId, page);
            String filename = String.format("original_page_%d.jpg", page);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .header("Content-Disposition", "attachment; filename=\"" + filename + "\"")
                .body(resource);
                
        } catch (Exception e) {
            log.error("下载原始图片失败", e);
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 健康检查
     */
    @GetMapping("/health")
    public ResponseEntity<ApiResponse<HealthResponse>> health() {
        HealthResponse health = new HealthResponse();
        health.setStatus("UP");
        health.setVersion("1.0.0");
        return ResponseEntity.ok(ApiResponse.success(health));
    }
}
```

### 8.5 DTO 类定义

```java
// ApiResponse.java - 统一响应格式
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse<T> {
    private Integer code;
    private String message;
    private T data;
    private String timestamp;
    
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(200, "success", data, 
            Instant.now().toString());
    }
    
    public static <T> ApiResponse<T> error(Integer code, String message) {
        return new ApiResponse<>(code, message, null, 
            Instant.now().toString());
    }
}

// InvoiceRecognizeResponse.java
@Data
public class InvoiceRecognizeResponse {
    private String taskId;
    private Integer totalInvoices;
    private List<InvoiceInfo> invoices;
    private Double processingTime;
    private String originalFileUrl;  // 原始文件预览URL（如果是单页图片）
}

// InvoiceInfo.java
@Data
public class InvoiceInfo {
    private Integer index;
    private Integer page;
    private List<Integer> bbox;
    private Double confidence;
    private String imageUrl;           // 裁切后图片预览URL
    private String downloadUrl;        // 裁切后图片下载URL
    private String originalImageUrl;   // 原始图片预览URL
    private String filename;
    
    // 构造函数
    public InvoiceInfo() {}
    
    // 便捷方法：获取完整预览URL（如果imageUrl是相对路径）
    public String getFullImageUrl(String baseUrl) {
        if (imageUrl != null && imageUrl.startsWith("http")) {
            return imageUrl;
        }
        return baseUrl + (imageUrl != null ? imageUrl : "/preview/cropped/" + filename);
    }
    
    public String getFullOriginalImageUrl(String baseUrl, String taskId) {
        if (originalImageUrl != null && originalImageUrl.startsWith("http")) {
            return originalImageUrl;
        }
        return baseUrl + "/preview/original/" + taskId + "?page=" + page;
    }
}

// AsyncTaskResponse.java
@Data
public class AsyncTaskResponse {
    private String taskId;
    private String status;
    private Integer estimatedTime;
}

// TaskStatusResponse.java
@Data
public class TaskStatusResponse {
    private String taskId;
    private String status;
    private Integer progress;
    private Integer totalInvoices;
    private List<InvoiceInfo> invoices;
    private String createdAt;
    private String completedAt;
}
```

### 8.6 全局异常处理

```java
package com.invoice.exception;

import com.invoice.dto.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

import java.time.Instant;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 处理文件大小超限异常
     */
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ApiResponse<Void>> handleMaxUploadSizeExceeded(
            MaxUploadSizeExceededException e) {
        log.warn("文件大小超限", e);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(400, "文件大小超过限制"));
    }
    
    /**
     * 处理服务异常
     */
    @ExceptionHandler(ServiceException.class)
    public ResponseEntity<ApiResponse<Void>> handleServiceException(
            ServiceException e) {
        log.error("服务异常", e);
        return ResponseEntity.status(e.getHttpStatus())
            .body(ApiResponse.error(e.getCode(), e.getMessage()));
    }
    
    /**
     * 处理参数验证异常
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<Void>> handleIllegalArgument(
            IllegalArgumentException e) {
        log.warn("参数错误", e);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(400, "参数错误: " + e.getMessage()));
    }
    
    /**
     * 处理通用异常
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleException(Exception e) {
        log.error("系统异常", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error(500, "系统内部错误"));
    }
}
```

### 8.7 业务系统调用示例

#### Java 调用示例

```java
@Service
public class BusinessService {
    
    private final RestTemplate restTemplate;
    private final String invoiceServiceUrl = "http://invoice-service:8080/api/v1/invoice";
    
    public List<InvoiceInfo> recognizeInvoices(MultipartFile file) {
        // 构建请求
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
        
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", file.getResource());
        body.add("cropPadding", "10");
        body.add("outputFormat", "jpg");
        
        HttpEntity<MultiValueMap<String, Object>> requestEntity = 
            new HttpEntity<>(body, headers);
        
        // 调用服务
        ResponseEntity<ApiResponse<InvoiceRecognizeResponse>> response = 
            restTemplate.postForEntity(
                invoiceServiceUrl + "/recognize-and-crop",
                requestEntity,
                new ParameterizedTypeReference<ApiResponse<InvoiceRecognizeResponse>>() {}
            );
        
        // 处理响应
        if (response.getStatusCode().is2xxSuccessful() && 
            response.getBody() != null && 
            response.getBody().getCode() == 200) {
            
            return response.getBody().getData().getInvoices();
        } else {
            throw new RuntimeException("识别失败");
        }
    }
}
```

#### Python 调用示例

```python
import requests

def recognize_invoices(file_path):
    url = "http://invoice-service:8080/api/v1/invoice/recognize-and-crop"
    
    with open(file_path, 'rb') as f:
        files = {'file': f}
        data = {
            'cropPadding': 10,
            'outputFormat': 'jpg'
        }
        
        response = requests.post(url, files=files, data=data)
        
        if response.status_code == 200:
            result = response.json()
            if result['code'] == 200:
                return result['data']['invoices']
            else:
                raise Exception(f"识别失败: {result['message']}")
        else:
            raise Exception(f"请求失败: {response.status_code}")
```

#### JavaScript/Node.js 调用示例

```javascript
const FormData = require('form-data');
const fs = require('fs');
const axios = require('axios');

async function recognizeInvoices(filePath) {
    const form = new FormData();
    form.append('file', fs.createReadStream(filePath));
    form.append('cropPadding', '10');
    form.append('outputFormat', 'jpg');
    
    try {
        const response = await axios.post(
            'http://invoice-service:8080/api/v1/invoice/recognize-and-crop',
            form,
            {
                headers: form.getHeaders()
            }
        );
        
        if (response.data.code === 200) {
            return response.data.data.invoices;
        } else {
            throw new Error(`识别失败: ${response.data.message}`);
        }
    } catch (error) {
        throw new Error(`请求失败: ${error.message}`);
    }
}
```

---

## 九、前端设计

### 9.1 前端架构概述

前端设计为**完全独立的前端应用**，与后端服务完全分离：
- **独立项目**: 前端和后端是独立的代码仓库和项目
- **独立部署**: 前端可以独立部署到 Nginx、CDN 等静态资源服务器
- **API 调用**: 前端通过 HTTP RESTful API 调用后端服务
- **无耦合**: 前端不依赖后端代码，后端不依赖前端代码

```
┌─────────────────────────────────────────────────────────┐
│                    前端应用 (Frontend)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  页面组件    │  │  状态管理    │  │  API 客户端   │  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
│         │                  │                  │          │
│         └──────────────────┴──────────────────┘          │
│                          │                               │
└──────────────────────────┼───────────────────────────────┘
                           │ HTTP RESTful API
                           ▼
        ┌──────────────────────────────────────┐
        │     后端服务 (Backend Service)        │
        │   (完全独立，不受前端影响)            │
        └──────────────────────────────────────┘
```

### 9.2 前端技术栈

#### 9.2.1 推荐技术栈

**方案一：React + TypeScript（推荐）**
- **框架**: React 18+
- **语言**: TypeScript
- **构建工具**: Vite
- **UI 组件库**: Ant Design / Material-UI
- **状态管理**: Zustand / Redux Toolkit
- **HTTP 客户端**: Axios
- **路由**: React Router

**方案二：Vue 3 + TypeScript**
- **框架**: Vue 3
- **语言**: TypeScript
- **构建工具**: Vite
- **UI 组件库**: Element Plus / Ant Design Vue
- **状态管理**: Pinia
- **HTTP 客户端**: Axios
- **路由**: Vue Router

**方案三：原生 HTML + JavaScript**
- **技术**: HTML5 + CSS3 + JavaScript (ES6+)
- **UI 框架**: Bootstrap / Tailwind CSS
- **HTTP 客户端**: Fetch API / Axios

### 9.3 前端项目结构

#### 9.3.1 React 项目结构

```
invoice-frontend/
├── public/                          # 静态资源
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── components/                  # 组件
│   │   ├── common/                 # 通用组件
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   └── Loading.tsx
│   │   ├── upload/                 # 上传组件
│   │   │   ├── FileUpload.tsx
│   │   │   └── UploadProgress.tsx
│   │   ├── result/                 # 结果展示组件
│   │   │   ├── InvoiceList.tsx
│   │   │   ├── InvoiceCard.tsx
│   │   │   └── ImagePreview.tsx
│   │   └── task/                  # 任务管理组件
│   │       ├── TaskStatus.tsx
│   │       └── TaskList.tsx
│   ├── pages/                      # 页面
│   │   ├── HomePage.tsx           # 首页
│   │   ├── UploadPage.tsx         # 上传页面
│   │   └── ResultPage.tsx         # 结果页面
│   ├── services/                   # API 服务
│   │   ├── api.ts                 # API 配置
│   │   ├── invoiceService.ts     # 发票服务
│   │   └── taskService.ts         # 任务服务
│   ├── store/                      # 状态管理
│   │   ├── invoiceStore.ts
│   │   └── taskStore.ts
│   ├── utils/                      # 工具函数
│   │   ├── request.ts             # HTTP 请求封装
│   │   └── format.ts              # 格式化工具
│   ├── types/                      # TypeScript 类型定义
│   │   ├── invoice.ts
│   │   └── api.ts
│   ├── styles/                     # 样式文件
│   │   ├── global.css
│   │   └── variables.css
│   ├── App.tsx                     # 根组件
│   └── main.tsx                    # 入口文件
├── package.json
├── tsconfig.json
├── vite.config.ts
└── README.md
```

### 9.4 前端页面设计

#### 9.4.1 页面结构

**主要页面**:
1. **首页/上传页面**: 文件上传、参数配置
2. **结果页面**: 识别结果展示、图片预览、下载
3. **任务管理页面**: 异步任务列表、状态查询

#### 9.4.2 页面功能设计

**上传页面功能**:
- 文件拖拽上传
- 文件格式验证（PDF、JPG、PNG）
- 文件大小限制提示
- 上传进度显示
- 参数配置（裁切边距、输出格式）
- 同步/异步处理选择

**结果页面功能**:
- 发票列表展示
- 每张发票的缩略图预览（裁切后）
- 原始图片预览（带识别区域标注）
- 裁切后图片预览
- 图片对比功能（原始 vs 裁切后）
- 边界框坐标显示
- 置信度显示
- 批量下载功能
- 单张图片下载（原始和裁切后）

**任务管理页面功能**:
- 任务列表（进行中、已完成、失败）
- 任务状态实时更新
- 任务详情查看
- 任务结果下载

### 9.5 API 客户端实现

#### 9.5.1 API 配置

```typescript
// src/services/api.ts
import axios from 'axios';

// API 基础配置
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 
  'http://localhost:8080/api/v1/invoice';

// 创建 axios 实例
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 60000, // 60秒超时
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    // 可以在这里添加 token 等认证信息
    // const token = localStorage.getItem('token');
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`;
    // }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => {
    return response.data;
  },
  (error) => {
    // 统一错误处理
    if (error.response) {
      const { code, message } = error.response.data || {};
      console.error('API 错误:', code, message);
    } else {
      console.error('网络错误:', error.message);
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

#### 9.5.2 发票服务封装

```typescript
// src/services/invoiceService.ts
import apiClient from './api';
import type { ApiResponse, InvoiceRecognizeResponse, InvoiceInfo } from '../types/api';

export interface RecognizeRequest {
  file: File;
  cropPadding?: number;
  outputFormat?: string;
}

export interface AsyncTaskResponse {
  taskId: string;
  status: string;
  estimatedTime?: number;
}

export interface TaskStatusResponse {
  taskId: string;
  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';
  progress: number;
  totalInvoices?: number;
  invoices?: InvoiceInfo[];
  createdAt: string;
  completedAt?: string;
}

class InvoiceService {
  /**
   * 同步识别与裁切
   */
  async recognizeAndCrop(
    file: File,
    cropPadding: number = 10,
    outputFormat: string = 'jpg'
  ): Promise<ApiResponse<InvoiceRecognizeResponse>> {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('cropPadding', cropPadding.toString());
    formData.append('outputFormat', outputFormat);

    return apiClient.post('/recognize-and-crop', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  }

  /**
   * 异步识别与裁切
   */
  async recognizeAndCropAsync(
    file: File,
    cropPadding: number = 10,
    outputFormat: string = 'jpg'
  ): Promise<ApiResponse<AsyncTaskResponse>> {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('cropPadding', cropPadding.toString());
    formData.append('outputFormat', outputFormat);

    return apiClient.post('/recognize-and-crop/async', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  }

  /**
   * 查询任务状态
   */
  async getTaskStatus(taskId: string): Promise<ApiResponse<TaskStatusResponse>> {
    return apiClient.get(`/task/${taskId}`);
  }

  /**
   * 获取裁切后图片预览URL
   */
  getCroppedImagePreviewUrl(filename: string): string {
    return `${apiClient.defaults.baseURL}/preview/cropped/${filename}`;
  }

  /**
   * 获取裁切后图片下载URL
   */
  getCroppedImageDownloadUrl(filename: string): string {
    return `${apiClient.defaults.baseURL}/download/${filename}`;
  }

  /**
   * 获取原始图片预览URL
   */
  getOriginalImagePreviewUrl(taskId: string, page: number = 1): string {
    return `${apiClient.defaults.baseURL}/preview/original/${taskId}?page=${page}`;
  }

  /**
   * 获取原始图片下载URL
   */
  getOriginalImageDownloadUrl(taskId: string, page: number = 1): string {
    return `${apiClient.defaults.baseURL}/download/original/${taskId}?page=${page}`;
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<ApiResponse<any>> {
    return apiClient.get('/health');
  }
}

export default new InvoiceService();
```

#### 9.5.3 TypeScript 类型定义

```typescript
// src/types/api.ts
export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
  timestamp: string;
}

export interface InvoiceInfo {
  index: number;
  page: number;
  bbox: number[];
  confidence: number;
  imageUrl: string;           // 裁切后图片预览URL
  downloadUrl?: string;       // 裁切后图片下载URL
  originalImageUrl?: string;  // 原始图片预览URL
  filename: string;
}

export interface InvoiceRecognizeResponse {
  taskId: string;
  totalInvoices: number;
  invoices: InvoiceInfo[];
  processingTime: number;
}
```

### 9.6 前端组件实现示例

#### 9.6.1 文件上传组件

```typescript
// src/components/upload/FileUpload.tsx
import React, { useState, useCallback } from 'react';
import { Upload, Button, message } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import type { UploadFile } from 'antd/es/upload/interface';
import invoiceService from '../../services/invoiceService';

interface FileUploadProps {
  onSuccess?: (response: any) => void;
  onError?: (error: any) => void;
  cropPadding?: number;
  outputFormat?: string;
  async?: boolean;
}

const FileUpload: React.FC<FileUploadProps> = ({
  onSuccess,
  onError,
  cropPadding = 10,
  outputFormat = 'jpg',
  async = false,
}) => {
  const [loading, setLoading] = useState(false);
  const [fileList, setFileList] = useState<UploadFile[]>([]);

  const handleUpload = useCallback(async (file: File) => {
    setLoading(true);
    try {
      let response;
      if (async) {
        response = await invoiceService.recognizeAndCropAsync(
          file,
          cropPadding,
          outputFormat
        );
        message.success('任务已提交，请前往任务管理查看进度');
      } else {
        response = await invoiceService.recognizeAndCrop(
          file,
          cropPadding,
          outputFormat
        );
        message.success(`识别完成，共识别到 ${response.data.totalInvoices} 张发票`);
      }
      
      onSuccess?.(response);
      setFileList([]);
    } catch (error: any) {
      const errorMsg = error.response?.data?.message || error.message || '上传失败';
      message.error(errorMsg);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [cropPadding, outputFormat, async, onSuccess, onError]);

  const beforeUpload = (file: File) => {
    // 文件格式验证
    const isValidType = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg'].includes(file.type);
    if (!isValidType) {
      message.error('只支持 PDF、JPG、PNG 格式的文件');
      return false;
    }

    // 文件大小验证（50MB）
    const isLt50M = file.size / 1024 / 1024 < 50;
    if (!isLt50M) {
      message.error('文件大小不能超过 50MB');
      return false;
    }

    handleUpload(file);
    return false; // 阻止自动上传
  };

  return (
    <Upload
      fileList={fileList}
      beforeUpload={beforeUpload}
      onChange={({ fileList }) => setFileList(fileList)}
      accept=".pdf,.jpg,.jpeg,.png"
      maxCount={1}
    >
      <Button icon={<UploadOutlined />} loading={loading}>
        选择文件
      </Button>
    </Upload>
  );
};

export default FileUpload;
```

#### 9.6.2 结果展示组件（支持预览）

```typescript
// src/components/result/InvoiceList.tsx
import React, { useState } from 'react';
import { Card, List, Image, Button, Space, Tag, Tabs, Modal } from 'antd';
import { DownloadOutlined, EyeOutlined } from '@ant-design/icons';
import type { InvoiceInfo } from '../../types/api';
import invoiceService from '../../services/invoiceService';

interface InvoiceListProps {
  invoices: InvoiceInfo[];
  taskId?: string; // 用于获取原始图片
}

const InvoiceList: React.FC<InvoiceListProps> = ({ invoices, taskId }) => {
  const [previewVisible, setPreviewVisible] = useState(false);
  const [previewImage, setPreviewImage] = useState<string>('');
  const [previewTitle, setPreviewTitle] = useState<string>('');

  const handleDownload = (filename: string, downloadUrl?: string) => {
    const url = downloadUrl || invoiceService.getCroppedImageDownloadUrl(filename);
    window.open(url, '_blank');
  };

  const handlePreview = (imageUrl: string, title: string) => {
    setPreviewImage(imageUrl);
    setPreviewTitle(title);
    setPreviewVisible(true);
  };

  return (
    <>
      <List
        grid={{ gutter: 16, xs: 1, sm: 2, md: 3, lg: 4 }}
        dataSource={invoices}
        renderItem={(invoice: InvoiceInfo) => (
          <List.Item>
            <Card
              hoverable
              cover={
                <div style={{ position: 'relative' }}>
                  <Image
                    src={invoice.imageUrl || invoiceService.getCroppedImagePreviewUrl(invoice.filename)}
                    alt={`发票 ${invoice.index + 1}`}
                    preview={false}
                    style={{ width: '100%', height: '200px', objectFit: 'cover' }}
                  />
                  <div style={{
                    position: 'absolute',
                    top: 8,
                    right: 8,
                    display: 'flex',
                    gap: 8
                  }}>
                    <Button
                      type="primary"
                      size="small"
                      icon={<EyeOutlined />}
                      onClick={() => handlePreview(
                        invoice.imageUrl || invoiceService.getCroppedImagePreviewUrl(invoice.filename),
                        `裁切后发票 ${invoice.index + 1}`
                      )}
                    >
                      预览
                    </Button>
                  </div>
                </div>
              }
              actions={[
                <Button
                  type="link"
                  icon={<EyeOutlined />}
                  onClick={() => handlePreview(
                    invoice.imageUrl || invoiceService.getCroppedImagePreviewUrl(invoice.filename),
                    `裁切后发票 ${invoice.index + 1}`
                  )}
                >
                  预览
                </Button>,
                <Button
                  type="link"
                  icon={<DownloadOutlined />}
                  onClick={() => handleDownload(invoice.filename, invoice.downloadUrl)}
                >
                  下载
                </Button>,
              ]}
            >
              <Card.Meta
                title={`发票 ${invoice.index + 1}`}
                description={
                  <Space direction="vertical" size="small" style={{ width: '100%' }}>
                    <div>页码: {invoice.page}</div>
                    <div>
                      坐标: [{invoice.bbox.join(', ')}]
                    </div>
                    <Tag color={invoice.confidence > 0.9 ? 'green' : 'orange'}>
                      置信度: {(invoice.confidence * 100).toFixed(1)}%
                    </Tag>
                    {invoice.originalImageUrl && (
                      <Space>
                        <Button
                          type="link"
                          size="small"
                          onClick={() => handlePreview(
                            invoice.originalImageUrl!,
                            `原始图片 - 第 ${invoice.page} 页`
                          )}
                        >
                          查看原始图片
                        </Button>
                        <Button
                          type="link"
                          size="small"
                          onClick={() => {
                            // 打开图片对比弹窗
                            // 可以使用 Modal 展示 ImageComparison 组件
                          }}
                        >
                          对比查看
                        </Button>
                      </Space>
                    )}
                  </Space>
                }
              />
            </Card>
          </List.Item>
        )}
      />
      
      <Modal
        open={previewVisible}
        title={previewTitle}
        footer={null}
        onCancel={() => setPreviewVisible(false)}
        width={800}
        centered
      >
        <Image
          src={previewImage}
          alt={previewTitle}
          style={{ width: '100%' }}
          preview={{
            mask: '点击放大',
          }}
        />
      </Modal>
    </>
  );
};

export default InvoiceList;
```

#### 9.6.3 图片对比预览组件（原始 vs 裁切后）

```typescript
// src/components/result/ImageComparison.tsx
import React, { useState } from 'react';
import { Card, Image, Tabs, Button, Space, Descriptions } from 'antd';
import { DownloadOutlined, EyeOutlined } from '@ant-design/icons';
import type { InvoiceInfo } from '../../types/api';
import invoiceService from '../../services/invoiceService';

interface ImageComparisonProps {
  invoice: InvoiceInfo;
  taskId?: string;
}

const ImageComparison: React.FC<ImageComparisonProps> = ({ invoice, taskId }) => {
  const [activeTab, setActiveTab] = useState<string>('cropped');

  const croppedImageUrl = invoice.imageUrl || 
    invoiceService.getCroppedImagePreviewUrl(invoice.filename);
  
  const originalImageUrl = invoice.originalImageUrl || 
    (taskId ? invoiceService.getOriginalImagePreviewUrl(taskId, invoice.page) : '');

  const tabItems = [
    {
      key: 'cropped',
      label: '裁切后',
      children: (
        <div style={{ textAlign: 'center' }}>
          <Image
            src={croppedImageUrl}
            alt="裁切后的发票"
            style={{ maxWidth: '100%', maxHeight: '600px' }}
            preview={{
              mask: '点击放大',
            }}
          />
          <div style={{ marginTop: 16 }}>
            <Button
              type="primary"
              icon={<DownloadOutlined />}
              onClick={() => {
                const url = invoice.downloadUrl || 
                  invoiceService.getCroppedImageDownloadUrl(invoice.filename);
                window.open(url, '_blank');
              }}
            >
              下载裁切后的图片
            </Button>
          </div>
        </div>
      ),
    },
    {
      key: 'original',
      label: '原始图片',
      children: originalImageUrl ? (
        <div style={{ textAlign: 'center', position: 'relative' }}>
          <Image
            src={originalImageUrl}
            alt="原始图片"
            style={{ maxWidth: '100%', maxHeight: '600px' }}
            preview={{
              mask: '点击放大',
            }}
          />
          {/* 在原始图片上标注识别区域 */}
          <div style={{ 
            position: 'absolute',
            border: '3px solid #ff4d4f',
            left: `${invoice.bbox[0]}px`,
            top: `${invoice.bbox[1]}px`,
            width: `${invoice.bbox[2] - invoice.bbox[0]}px`,
            height: `${invoice.bbox[3] - invoice.bbox[1]}px`,
            pointerEvents: 'none',
            boxShadow: '0 0 10px rgba(255, 77, 79, 0.5)'
          }}>
            <div style={{
              position: 'absolute',
              top: -28,
              left: 0,
              background: '#ff4d4f',
              color: 'white',
              padding: '4px 8px',
              fontSize: '12px',
              fontWeight: 'bold',
              borderRadius: '4px'
            }}>
              识别区域
            </div>
          </div>
          <div style={{ marginTop: 16 }}>
            <Button
              type="primary"
              icon={<DownloadOutlined />}
              onClick={() => {
                if (taskId) {
                  const url = invoiceService.getOriginalImageDownloadUrl(taskId, invoice.page);
                  window.open(url, '_blank');
                }
              }}
            >
              下载原始图片
            </Button>
          </div>
        </div>
      ) : (
        <div style={{ textAlign: 'center', padding: '40px' }}>
          原始图片不可用
        </div>
      ),
    },
    {
      key: 'info',
      label: '详细信息',
      children: (
        <Descriptions bordered column={1}>
          <Descriptions.Item label="发票序号">{invoice.index + 1}</Descriptions.Item>
          <Descriptions.Item label="页码">{invoice.page}</Descriptions.Item>
          <Descriptions.Item label="边界框坐标">
            [{invoice.bbox.join(', ')}]
          </Descriptions.Item>
          <Descriptions.Item label="置信度">
            {(invoice.confidence * 100).toFixed(2)}%
          </Descriptions.Item>
          <Descriptions.Item label="文件名">{invoice.filename}</Descriptions.Item>
        </Descriptions>
      ),
    },
  ];

  return (
    <Card title={`发票 ${invoice.index + 1} - 图片对比`}>
      <Tabs
        activeKey={activeTab}
        onChange={setActiveTab}
        items={tabItems}
      />
    </Card>
  );
};

export default ImageComparison;
```

#### 9.6.4 图片对比预览组件

```typescript
// src/components/result/ImageComparison.tsx
import React, { useState } from 'react';
import { Card, Image, Tabs, Button, Space } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import type { InvoiceInfo } from '../../types/api';
import invoiceService from '../../services/invoiceService';

interface ImageComparisonProps {
  invoice: InvoiceInfo;
  taskId?: string;
}

const ImageComparison: React.FC<ImageComparisonProps> = ({ invoice, taskId }) => {
  const [activeTab, setActiveTab] = useState<string>('cropped');

  const croppedImageUrl = invoice.imageUrl || 
    invoiceService.getCroppedImagePreviewUrl(invoice.filename);
  
  const originalImageUrl = invoice.originalImageUrl || 
    (taskId ? invoiceService.getOriginalImagePreviewUrl(taskId, invoice.page) : '');

  const tabItems = [
    {
      key: 'cropped',
      label: '裁切后',
      children: (
        <div style={{ textAlign: 'center' }}>
          <Image
            src={croppedImageUrl}
            alt="裁切后的发票"
            style={{ maxWidth: '100%', maxHeight: '600px' }}
            preview={{
              mask: '点击放大',
            }}
          />
          <div style={{ marginTop: 16 }}>
            <Button
              type="primary"
              icon={<DownloadOutlined />}
              onClick={() => {
                const url = invoice.downloadUrl || 
                  invoiceService.getCroppedImageDownloadUrl(invoice.filename);
                window.open(url, '_blank');
              }}
            >
              下载裁切后的图片
            </Button>
          </div>
        </div>
      ),
    },
    {
      key: 'original',
      label: '原始图片',
      children: originalImageUrl ? (
        <div style={{ textAlign: 'center' }}>
          <Image
            src={originalImageUrl}
            alt="原始图片"
            style={{ maxWidth: '100%', maxHeight: '600px' }}
            preview={{
              mask: '点击放大',
            }}
          />
          <div style={{ marginTop: 16 }}>
            <div style={{ 
              position: 'absolute',
              border: '2px solid red',
              left: `${invoice.bbox[0]}px`,
              top: `${invoice.bbox[1]}px`,
              width: `${invoice.bbox[2] - invoice.bbox[0]}px`,
              height: `${invoice.bbox[3] - invoice.bbox[1]}px`,
              pointerEvents: 'none'
            }}>
              <div style={{
                position: 'absolute',
                top: -24,
                left: 0,
                background: 'red',
                color: 'white',
                padding: '2px 8px',
                fontSize: '12px'
              }}>
                识别区域
              </div>
            </div>
            <Button
              type="primary"
              icon={<DownloadOutlined />}
              onClick={() => {
                if (taskId) {
                  const url = invoiceService.getOriginalImageDownloadUrl(taskId, invoice.page);
                  window.open(url, '_blank');
                }
              }}
            >
              下载原始图片
            </Button>
          </div>
        </div>
      ) : (
        <div style={{ textAlign: 'center', padding: '40px' }}>
          原始图片不可用
        </div>
      ),
    },
  ];

  return (
    <Card title={`发票 ${invoice.index + 1} - 图片对比`}>
      <Tabs
        activeKey={activeTab}
        onChange={setActiveTab}
        items={tabItems}
      />
    </Card>
  );
};

export default ImageComparison;
```

#### 9.6.3 任务状态组件

```typescript
// src/components/task/TaskStatus.tsx
import React, { useEffect, useState } from 'react';
import { Card, Progress, Tag, Button } from 'antd';
import { ReloadOutlined } from '@ant-design/icons';
import invoiceService from '../../services/invoiceService';
import type { TaskStatusResponse } from '../../services/invoiceService';

interface TaskStatusProps {
  taskId: string;
  onComplete?: (response: TaskStatusResponse) => void;
}

const TaskStatus: React.FC<TaskStatusProps> = ({ taskId, onComplete }) => {
  const [taskStatus, setTaskStatus] = useState<TaskStatusResponse | null>(null);
  const [loading, setLoading] = useState(false);

  const fetchTaskStatus = async () => {
    setLoading(true);
    try {
      const response = await invoiceService.getTaskStatus(taskId);
      setTaskStatus(response.data);
      
      if (response.data.status === 'COMPLETED' && onComplete) {
        onComplete(response.data);
      }
    } catch (error) {
      console.error('查询任务状态失败', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTaskStatus();
    const interval = setInterval(() => {
      if (taskStatus?.status === 'PROCESSING' || taskStatus?.status === 'PENDING') {
        fetchTaskStatus();
      }
    }, 2000); // 每2秒轮询一次

    return () => clearInterval(interval);
  }, [taskId, taskStatus?.status]);

  if (!taskStatus) {
    return <div>加载中...</div>;
  }

  const statusColor = {
    PENDING: 'default',
    PROCESSING: 'processing',
    COMPLETED: 'success',
    FAILED: 'error',
  }[taskStatus.status];

  return (
    <Card
      title={`任务 ${taskId}`}
      extra={
        <Button
          icon={<ReloadOutlined />}
          onClick={fetchTaskStatus}
          loading={loading}
        >
          刷新
        </Button>
      }
    >
      <Space direction="vertical" style={{ width: '100%' }}>
        <div>
          状态: <Tag color={statusColor}>{taskStatus.status}</Tag>
        </div>
        {taskStatus.status === 'PROCESSING' && (
          <Progress percent={taskStatus.progress} />
        )}
        {taskStatus.status === 'COMPLETED' && (
          <div>
            <div>识别到 {taskStatus.totalInvoices} 张发票</div>
            <div>完成时间: {new Date(taskStatus.completedAt!).toLocaleString()}</div>
          </div>
        )}
      </Space>
    </Card>
  );
};

export default TaskStatus;
```

### 9.7 预览功能说明

#### 9.7.1 预览功能概述

预览功能支持两种类型的图片预览：

1. **原始图片预览**
   - 显示用户上传的原始文件（PDF转图片后或直接上传的图片）
   - 在原始图片上标注识别出的发票区域（红色边框）
   - 支持多页PDF的逐页预览

2. **裁切后图片预览**
   - 显示根据识别结果裁切后的独立发票图片
   - 清晰展示每张发票的完整内容
   - 支持放大查看

#### 9.7.2 预览功能特性

- **图片对比**: 可以在同一界面对比查看原始图片和裁切后的图片
- **区域标注**: 在原始图片上标注识别区域，方便验证识别准确性
- **响应式设计**: 支持不同屏幕尺寸的预览
- **缓存优化**: 预览图片支持浏览器缓存，提升加载速度
- **下载功能**: 支持下载原始图片和裁切后的图片

#### 9.7.3 预览URL生成规则

**原始图片预览URL**:
```
GET /api/v1/invoice/preview/original/{taskId}?page={page}
```
- `taskId`: 任务ID，用于定位原始文件
- `page`: PDF页码（从1开始），如果是单页图片，默认为1

**裁切后图片预览URL**:
```
GET /api/v1/invoice/preview/cropped/{filename}
```
- `filename`: 裁切后的文件名，格式为 `invoice_{page}_{index}.jpg`

#### 9.7.4 预览功能实现要点

1. **原始文件存储**
   - 上传的文件需要保存到 `uploads/original/` 目录
   - PDF文件转换后的图片也需要保存
   - 文件命名规则：`{taskId}_page_{page}.jpg`

2. **URL生成时机**
   - 在识别完成后，为每个发票生成预览URL
   - URL包含在API响应中，前端直接使用

3. **图片缓存策略**
   - 预览接口设置 `Cache-Control: public, max-age=3600`
   - 下载接口设置 `Content-Disposition: attachment`

### 9.8 前端页面实现示例

#### 9.8.1 主页面

```typescript
// src/pages/HomePage.tsx
import React, { useState } from 'react';
import { Card, Form, InputNumber, Radio, Space, Divider } from 'antd';
import FileUpload from '../components/upload/FileUpload';
import InvoiceList from '../components/result/InvoiceList';
import type { InvoiceRecognizeResponse } from '../types/api';

const HomePage: React.FC = () => {
  const [form] = Form.useForm();
  const [result, setResult] = useState<InvoiceRecognizeResponse | null>(null);
  const [processingMode, setProcessingMode] = useState<'sync' | 'async'>('sync');

  const handleSuccess = (response: any) => {
    if (response.data.invoices) {
      setResult(response.data);
    }
  };

  return (
    <div style={{ padding: '24px', maxWidth: '1200px', margin: '0 auto' }}>
      <Card title="发票识别与裁切" style={{ marginBottom: '24px' }}>
        <Form form={form} layout="vertical">
          <Form.Item label="处理模式">
            <Radio.Group
              value={processingMode}
              onChange={(e) => setProcessingMode(e.target.value)}
            >
              <Radio value="sync">同步处理</Radio>
              <Radio value="async">异步处理</Radio>
            </Radio.Group>
          </Form.Item>

          <Form.Item label="裁切边距（像素）" name="cropPadding" initialValue={10}>
            <InputNumber min={0} max={50} />
          </Form.Item>

          <Form.Item label="输出格式" name="outputFormat" initialValue="jpg">
            <Radio.Group>
              <Radio value="jpg">JPG</Radio>
              <Radio value="png">PNG</Radio>
            </Radio.Group>
          </Form.Item>

          <Form.Item label="上传文件">
            <FileUpload
              async={processingMode === 'async'}
              cropPadding={form.getFieldValue('cropPadding')}
              outputFormat={form.getFieldValue('outputFormat')}
              onSuccess={handleSuccess}
            />
          </Form.Item>
        </Form>
      </Card>

      {result && (
        <>
          <Divider />
          <Card title={`识别结果（共 ${result.totalInvoices} 张发票）`}>
            <InvoiceList invoices={result.invoices} taskId={result.taskId} />
          </Card>
        </>
      )}
    </div>
  );
};

export default HomePage;
```

### 9.9 前端环境配置

#### 9.8.1 环境变量配置

```bash
# .env.development
VITE_API_BASE_URL=http://localhost:8080/api/v1/invoice

# .env.production
VITE_API_BASE_URL=https://api.example.com/api/v1/invoice
```

#### 9.8.2 Vite 配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: false,
  },
});
```

### 9.10 前端部署方案

#### 9.9.1 构建前端项目

```bash
# 安装依赖
npm install

# 开发环境运行
npm run dev

# 生产环境构建
npm run build
```

#### 9.9.2 Nginx 部署配置

```nginx
server {
    listen 80;
    server_name invoice-frontend.example.com;
    root /var/www/invoice-frontend/dist;
    index index.html;

    # 前端路由支持（SPA）
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API 代理（可选，也可以直接在前端配置 API 地址）
    location /api {
        proxy_pass http://invoice-service:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

#### 9.9.3 Docker 部署前端

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci

# 复制源代码并构建
COPY . .
RUN npm run build

# 生产环境镜像
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制 Nginx 配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 9.11 前后端分离说明

#### 9.10.1 完全分离的保证

1. **独立代码仓库**
   - 前端代码：`invoice-frontend` 仓库
   - 后端代码：`invoice-service` 仓库
   - 互不依赖，独立维护

2. **独立部署**
   - 前端部署到 Nginx/CDN
   - 后端部署到应用服务器
   - 可以分别进行版本管理和发布

3. **API 契约**
   - 前后端通过 RESTful API 通信
   - API 文档作为契约（Swagger/OpenAPI）
   - 前端不关心后端实现细节

4. **CORS 配置**
   - 后端需要配置 CORS 支持跨域
   - 前端可以配置代理或直接调用 API

#### 9.10.2 后端 CORS 配置

```java
// 后端需要添加 CORS 配置
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("*")  // 生产环境应该配置具体的前端域名
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

### 9.11 前端项目依赖

#### 9.11.1 package.json（React 示例）

```json
{
  "name": "invoice-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "antd": "^5.11.0",
    "axios": "^1.6.0",
    "zustand": "^4.4.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0"
  }
}
```

---

## 十、文件结构设计

### 7.1 推荐目录结构

```
invoice/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── invoice/
│       │           ├── InvoiceApplication.java      # Spring Boot 主类
│       │           ├── config/
│       │           │   ├── VolcengineConfig.java     # 火山引擎配置
│       │           │   ├── AppConfig.java            # 应用配置
│       │           │   └── SchedulingConfig.java     # 定时任务配置
│       │           ├── controller/
│       │           │   └── InvoiceController.java    # REST API 控制器
│       │           ├── dto/
│       │           │   ├── ApiResponse.java          # 统一响应格式
│       │           │   ├── InvoiceRecognizeRequest.java
│       │           │   ├── InvoiceRecognizeResponse.java
│       │           │   ├── AsyncTaskResponse.java
│       │           │   └── TaskStatusResponse.java
│       │           ├── exception/
│       │           │   ├── GlobalExceptionHandler.java  # 全局异常处理
│       │           │   └── ServiceException.java        # 服务异常
│       │           ├── service/
│       │           │   ├── VolcengineClient.java           # 火山引擎客户端
│       │           │   ├── VolcengineApiService.java       # API 调用服务
│       │           │   ├── InvoiceRecognitionService.java  # 发票识别服务
│       │           │   ├── PdfProcessor.java               # PDF 处理服务
│       │           │   ├── ImageCropService.java           # 图像裁切服务
│       │           │   ├── InvoiceService.java             # 发票处理主服务
│       │           │   └── FileCleanupService.java         # 文件清理服务
│       │           ├── util/
│       │           │   ├── ImageUtils.java          # 图像工具类
│       │           │   ├── BboxValidator.java       # 坐标验证工具
│       │           │   └── ApiResponseParser.java  # API 响应解析
│       │           └── model/
│       │               └── InvoiceInfo.java         # 发票信息模型
│       └── resources/
│           ├── application.yml                      # 配置文件
│           ├── application-local.yml                # 本地配置（不提交）
│           └── logback-spring.xml                  # 日志配置
├── pom.xml                                          # Maven 依赖配置
├── .gitignore                                      # Git 忽略文件
├── uploads/                                         # 上传文件临时目录
├── outputs/                                         # 输出发票图片目录
├── temp/                                            # 临时文件目录
├── logs/                                            # 日志目录（可选）
└── README.md                                        # 使用说明
```

### 7.2 创建必要目录

```bash
mkdir uploads    # 上传文件目录
mkdir outputs    # 输出文件目录
mkdir temp       # 临时文件目录
mkdir logs       # 日志目录（可选）
```

---

## 十一、服务部署方案

### 10.1 部署方式

#### 10.1.1 传统部署

**使用 JAR 包部署**:

```bash
# 1. 打包
mvn clean package

# 2. 运行
java -jar invoice-service-1.0.0.jar \
  --spring.profiles.active=prod \
  --server.port=8080
```

#### 10.1.2 Docker 部署

**Dockerfile**:

```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

# 复制 JAR 文件
COPY target/invoice-service-1.0.0.jar app.jar

# 创建必要的目录
RUN mkdir -p /app/uploads /app/outputs /app/temp /app/logs

# 暴露端口
EXPOSE 8080

# 设置环境变量
ENV SPRING_PROFILES_ACTIVE=prod
ENV ARK_API_KEY=""

# 运行应用
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  invoice-service:
    build: .
    container_name: invoice-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - ARK_API_KEY=${ARK_API_KEY}
      - VOLCENGINE_BASE_URL=https://ark.cn-beijing.volces.com/api/v3
    volumes:
      - ./uploads:/app/uploads
      - ./outputs:/app/outputs
      - ./temp:/app/temp
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/v1/invoice/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

#### 10.1.3 Kubernetes 部署

**deployment.yaml**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: invoice-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: invoice-service
  template:
    metadata:
      labels:
        app: invoice-service
    spec:
      containers:
      - name: invoice-service
        image: invoice-service:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: ARK_API_KEY
          valueFrom:
            secretKeyRef:
              name: volcengine-secret
              key: api-key
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /api/v1/invoice/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/v1/invoice/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: invoice-service
spec:
  selector:
    app: invoice-service
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

### 10.2 配置管理

#### 10.2.1 环境变量配置

```bash
# 生产环境
export ARK_API_KEY=your_production_api_key
export SPRING_PROFILES_ACTIVE=prod
export SERVER_PORT=8080
export LOG_LEVEL=INFO
```

#### 10.2.2 配置文件分离

```
resources/
├── application.yml              # 通用配置
├── application-dev.yml          # 开发环境
├── application-test.yml          # 测试环境
└── application-prod.yml         # 生产环境
```

### 10.3 监控与日志

#### 10.3.1 健康检查

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always
```

#### 10.3.2 日志配置

```yaml
logging:
  level:
    root: INFO
    com.invoice: DEBUG
  file:
    name: logs/invoice-service.log
    max-size: 100MB
    max-history: 30
```

### 10.4 服务注册（可选）

如果使用微服务架构，可以集成服务注册中心：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_SERVER:localhost:8848}
        namespace: ${NACOS_NAMESPACE:}
        group: ${NACOS_GROUP:DEFAULT_GROUP}
        service-name: invoice-service
```

---

## 十二、注意事项与实现优先级

### 8.1 重要注意事项

1. **PDF 处理**
   - PDF 需要先转换为图片，模型不支持直接处理 PDF
   - 多页 PDF 需要逐页处理
   - 注意 PDF 转图片的质量设置（DPI）

2. **模型返回格式**
   - 需要根据实际 API 文档确认返回的定位信息格式
   - 可能需要使用 prompt 引导模型返回结构化数据
   - 实现健壮的 JSON 解析和错误处理

3. **坐标系统**
   - 确认模型返回的坐标是像素坐标还是归一化坐标
   - 注意坐标原点位置（左上角 vs 左下角）
   - 实现坐标验证和修正机制

4. **错误处理**
   - 文件格式验证
   - API 调用失败重试机制
   - 图片处理异常处理
   - 坐标无效时的处理策略

5. **性能优化**
   - 大文件分块处理
   - 异步处理长时间任务
   - 临时文件清理（定时任务自动清理）
   - 内存管理（及时释放图片对象）

6. **资源回收**
   - 使用 Spring Task 定时清理临时文件
   - 清理超过保留时间的文件（默认24小时）
   - 自动删除空目录
   - 记录清理日志，便于监控

7. **图片格式**
   - BufferedImage 使用 RGB 格式
   - OpenCV Java 使用 BGR 格式
   - 保存时注意格式转换
   - 确保输出图片质量

8. **边距处理**
   - 添加边距时要确保不超出图片边界
   - 边距大小根据实际需求调整

9. **API 配额**
   - 注意 API 调用频率限制
   - 实现适当的限流机制

### 8.2 实现优先级

#### 第一阶段: 基础功能与服务化
- [ ] PDF/图片上传功能
- [ ] PDF 转图片功能
- [ ] 火山引擎 API 调用
- [ ] 基础裁切功能
- [ ] 文件保存功能
- [ ] RESTful API 接口实现
- [ ] 统一响应格式
- [ ] 全局异常处理
- [ ] 健康检查接口
- [ ] 后端 CORS 配置
- [ ] 资源回收服务（定时清理）
- [ ] 定时任务配置

#### 第二阶段: 优化与服务增强
- [ ] 错误处理完善
- [ ] 重试机制实现
- [ ] 性能优化
- [ ] 批量处理支持
- [ ] 日志记录
- [ ] 异步任务处理
- [ ] 任务状态查询接口
- [ ] API 文档（Swagger/OpenAPI）
- [ ] 服务监控和指标
- [ ] 资源回收机制完善
- [ ] 清理策略优化
- [ ] 前端基础页面开发
- [ ] 文件上传组件
- [ ] 结果展示组件
- [ ] 图片预览组件（原始和裁切后）
- [ ] 图片对比功能
- [ ] 前端 API 客户端封装

#### 第三阶段: 增强与扩展
- [ ] 服务注册与发现（Nacos/Consul）
- [ ] 负载均衡配置
- [ ] 服务限流和熔断
- [ ] Docker 容器化部署
- [ ] Kubernetes 部署配置
- [ ] 分布式任务调度
- [ ] 结果缓存机制
- [ ] 图片质量增强
- [ ] 旋转校正（可选）
- [ ] 多模型支持
- [ ] 前端任务管理页面
- [ ] 前端实时状态更新
- [ ] 前端批量下载功能
- [ ] 原始图片预览功能完善
- [ ] 图片对比功能优化
- [ ] 前端部署优化（CDN、缓存）

### 8.3 配置验证清单

在开始实现前，请确认：

- [ ] 火山引擎账号已创建
- [ ] API Key 已获取（从方舟推理接入点获取）
- [ ] API Key 已配置（环境变量 `ARK_API_KEY` 或配置文件）
- [ ] Base URL 已确认（默认: `https://ark.cn-beijing.volces.com/api/v3`）
- [ ] 模型名称已确认（`doubao-seed-1-6-vision-250815`）
- [ ] 推理接入点 ID 已创建并配置
- [ ] Java 环境已安装（JDK 8+）
- [ ] Maven 或 Gradle 已安装
- [ ] 所有必要的目录已创建（uploads, outputs, temp）
- [ ] 依赖包已安装（`mvn install` 或 `gradle build`）
- [ ] 配置文件已设置（`application.yml` 或 `application.properties`）
- [ ] `.gitignore` 已配置（保护敏感信息，如 `application-local.yml`）
- [ ] 资源回收配置已设置（清理策略、保留时间）
- [ ] 定时任务已启用（`@EnableScheduling`）
- [ ] 清理目录权限已配置（读写权限）
- [ ] 磁盘空间监控已配置（可选）
- [ ] 测试数据已准备

### 8.4 数据流示例

#### 输入数据
```
文件: invoice.pdf (3页)
或
文件: invoice.jpg
```

#### 中间数据
```
图片数组:
[
  page1_image (BufferedImage),
  page2_image (BufferedImage),
  page3_image (BufferedImage)
]
```

#### API 返回数据 (示例)
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "invoices": [
      {
        "bbox": [100, 200, 800, 1200],
        "confidence": 0.95,
        "page": 1
      },
      {
        "bbox": [100, 1400, 800, 2400],
        "confidence": 0.92,
        "page": 1
      },
      {
        "bbox": [100, 200, 800, 1200],
        "confidence": 0.98,
        "page": 2
      }
    ]
  }
}
```

#### 输出数据
```
文件列表:
- outputs/invoice_1_0.jpg (第1页第1张发票)
- outputs/invoice_1_1.jpg (第1页第2张发票)
- outputs/invoice_2_0.jpg (第2页第1张发票)
```

---

## 十三、参考资源

- 火山引擎 SDK 文档: https://www.volcengine.com/docs/
- Doubao-Seed-1.6-vision 模型文档
- Apache PDFBox 文档: https://pdfbox.apache.org/
- OpenCV Java 文档: https://docs.opencv.org/
- Spring Boot 文档: https://spring.io/projects/spring-boot
- Java BufferedImage API: https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html

---

**文档版本**: 1.0  
**最后更新**: 2024年

